-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParGo where
import AbsGo
import LexGo
import ErrM
import Control.Monad
import Env
import TAC
}

------------------------
-- Attributed grammar --
------------------------

%attributetype        { MyAttributes a }

%attribute value      { a }

-- actual environment attributes for variables and functions
%attribute envVar     { [ElemVar] }        
%attribute envFun     { [ElemFun] }

-- new environment attributes for variables and functions
%attribute envVarNew  { [ElemVar] }
%attribute envFunNew  { [ElemFun] }

-- line position used for list of parameters in functions declarations
%attribute posi       { String }

-- list of variables identifiers (for multiple declaration)
%attribute idList     { [Id] }

-- type on an expression
%attribute aType      { Type }

-- type of a list of expressions
%attribute aTypeList  { [Type] }

-- return type of a function 
%attribute aTypeFun   { Type }

-- defines if a return instruction is needed (true) or not (false)
%attribute aReturn    { Bool }

-- used to manage errors and 'break' and 'continue' instructions
%attribute forLabels  { (Int, Int) }

-- catch (previous) expression's errors 
%attribute err        { String }

-- used to manage short-cuts (next instruction label value)
%attribute true       { Int }
%attribute false      { Int }


-- TAC generation attributes --

-- (actual and new) temporal variable and label indexes 
%attribute index      { (Int, Int) }
%attribute indexNew   { (Int, Int) }

-- list of TAC operations (tacJ is used to manage short-cut operations)
%attribute tac        { [TacLine] }
%attribute tacJ       { [TacLine] }

-- contains actual expression(s) to print
%attribute tacId      { String }
%attribute tacIdList  { [String] }

------------------
------------------

%name pStart Start
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }
%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '%' { PT _ (TS _ 3) }
  '&' { PT _ (TS _ 4) }
  '&&' { PT _ (TS _ 5) }
  '(' { PT _ (TS _ 6) }
  ')' { PT _ (TS _ 7) }
  '*' { PT _ (TS _ 8) }
  '+' { PT _ (TS _ 9) }
  ',' { PT _ (TS _ 10) }
  '-' { PT _ (TS _ 11) }
  '/' { PT _ (TS _ 12) }
  ':=' { PT _ (TS _ 13) }
  ';' { PT _ (TS _ 14) }
  '<' { PT _ (TS _ 15) }
  '<=' { PT _ (TS _ 16) }
  '=' { PT _ (TS _ 17) }
  '==' { PT _ (TS _ 18) }
  '>' { PT _ (TS _ 19) }
  '>=' { PT _ (TS _ 20) }
  '[' { PT _ (TS _ 21) }
  ']' { PT _ (TS _ 22) }
  'bool' { PT _ (TS _ 23) }
  'break' { PT _ (TS _ 24) }
  'catch' { PT _ (TS _ 25) }
  'char' { PT _ (TS _ 26) }
  'continue' { PT _ (TS _ 27) }
  'do' { PT _ (TS _ 28) }
  'else' { PT _ (TS _ 29) }
  'false' { PT _ (TS _ 30) }
  'float' { PT _ (TS _ 31) }
  'for' { PT _ (TS _ 32) }
  'func' { PT _ (TS _ 33) }
  'if' { PT _ (TS _ 34) }
  'int' { PT _ (TS _ 35) }
  'package' { PT _ (TS _ 36) }
  'readChar' { PT _ (TS _ 37) }
  'readFloat' { PT _ (TS _ 38) }
  'readInt' { PT _ (TS _ 39) }
  'readString' { PT _ (TS _ 40) }
  'ref' { PT _ (TS _ 41) }
  'return' { PT _ (TS _ 42) }
  'string' { PT _ (TS _ 43) }
  'true' { PT _ (TS _ 44) }
  'try' { PT _ (TS _ 45) }
  'val' { PT _ (TS _ 46) }
  'var' { PT _ (TS _ 47) }
  'void' { PT _ (TS _ 48) }
  'writeChar' { PT _ (TS _ 49) }
  'writeFloat' { PT _ (TS _ 50) }
  'writeInt' { PT _ (TS _ 51) }
  'writeString' { PT _ (TS _ 52) }
  '{' { PT _ (TS _ 53) }
  '||' { PT _ (TS _ 54) }
  '}' { PT _ (TS _ 55) }


L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_quoted { PT _ (TL $$) }
L_Id { PT _ (T_Id $$) }


%left '='
%left '&&' '||'
%nonassoc '==' '!=' '<' '<=' '>' '>='  '!'
%left '+' '-'
%left '*' '/' '%'
%left NEG
%left PTR



%%

Integer : L_integ  { $$ = read $1 :: Integer }
Double  : L_doubl  { $$ = read $1 :: Double }
Char    : L_charac { $$ = read $1 :: Char }
String  : L_quoted { $$ = $1 }
Id      : L_Id     { $$ = Id $1}

Boolean : 'true'  { $$ = Boolean_true; } 
        | 'false' { $$ = Boolean_false; }

Type : 'void'      { $$ = TVoid; $$.posi = pos $1}
     | 'int'       { $$ = TInt; $$.posi = pos $1}
     | 'bool'      { $$ = TBool; $$.posi = pos $1}
     | 'float'     { $$ = TFloat; $$.posi = pos $1}
     | 'char'      { $$ = TChar; $$.posi = pos $1}
     | 'string'    { $$ = TString; $$.posi = pos $1}
     | '[' Integer ']' Type    { $$ = TArray $2 $4; $$.posi = pos $1}
     | '*' Type    %prec PTR   { $$ = TPointer $2; $$.posi = pos $1}

Pass : 'val'     { $$ = PassVal; }
     | 'ref'     { $$ = PassRef; }

RExp : RExp '&&' RExp {
            $$ = ExpAnd $1 $3; 
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = TBool;
            $$.err = checkBoolOp $1.aType $3.aType $1.err $3.err $2;
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = ( (fst $3.indexNew) + 1, snd $3.indexNew );
            $1.true = snd $1.indexNew;
            $1.false = $$.false;
            $3.true = $$.true;
            $3.false = $$.false;
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $1.tac++$3.tac++[BinOp "&&" $$.tacId $1.tacId $3.tacId];
            $$.tacJ = $1.tacJ++[CondJFalse $1.tacId ($1.true+1)]++$3.tacJ++[BinOp "&&" $$.tacId $1.tacId $3.tacId];
            where case checkBoolOp $1.aType $3.aType $1.err $3.err $2 of {
                       "" -> Ok ();
                       x  -> Bad x;
                  };
            }

     | RExp '||' RExp {
            $$ = ExpOr $1 $3; 
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = TBool;
            $$.err = checkBoolOp $1.aType $3.aType $1.err $3.err $2;
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = $3.indexNew;
            $1.true = snd $1.indexNew;
            $1.false = $$.false;
            $3.true = $$.true;
            $3.false = $$.false;
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $1.tac++$3.tac++[BinOp "||" $$.tacId $1.tacId $3.tacId];
            $$.tacJ = $1.tacJ++[CondJTrue $1.tacId ($1.true)]++$3.tacJ++[BinOp "||" $$.tacId $1.tacId $3.tacId];
            where case checkBoolOp $1.aType $3.aType $1.err $3.err $2 of {
                       "" -> Ok ();
                       x  -> Bad x;               
                  };
            }

     | '!' RExp {
            $$ = ExpNot $2; 
            $2.envVar = $$.envVar;
            $2.envFun = $$.envFun;
            $$.aType = TBool;
            $$.err = if $2.err == ""
                       then if not $ $2.aType == TBool
                              then "Type error at "++(pos $1)++": expected type: boolean"
                              else ""
                       else $2.err ;
            $2.index = $$.index;
            $$.indexNew = ( (fst $2.indexNew) + 1, snd $2.indexNew );
            $$.tacId = "t"++(show  $ fst $$.indexNew );
            $$.tac = $2.tac++[UnOp "not " $$.tacId $2.tacId];
            $$.tacJ = $$.tac;
            where if $2.err == ""
                    then if not $ $2.aType == TBool
                           then Bad $ "Type error at "++(pos $1)++": expected type: boolean"
                           else Ok ()
                    else Bad $2.err ;
            }

     | RExp '==' RExp {
            $$ = ExpEq $1 $3; 
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = TBool;
            $$.err = checkRelOp $1.aType $3.aType $1.err $3.err $2;
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = ( (fst $3.indexNew) + 1, snd $3.indexNew );
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $1.tac++$3.tac++
                     case ($1.aType,$3.aType) of {
                          (TFloat,TInt) -> [BinOp "eqTo_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                          (TFloat,TBool) -> [BinOp "eqTo_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                          (TInt,TFloat) -> [BinOp "eqTo_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                          (TInt,TBool) -> [BinOp "eqTo_int" $$.tacId $1.tacId ("(int)"++$3.tacId)];
                          (TBool,TFloat) -> [BinOp "eqTo_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                          (TBool,TInt) -> [BinOp "eqTo_int" $$.tacId ("(int)"++$1.tacId) $3.tacId];
                          (x,_) -> [BinOp ("eqTo_"++(showType x)) $$.tacId $1.tacId $3.tacId];
                     };
            $$.tacJ = $$.tac;
            where case checkRelOp $1.aType $3.aType $1.err $3.err $2 of {
                       "" -> Ok ();
                       x  -> Bad x;               
                  };
            }

     | RExp '!=' RExp {
            $$ = ExpNeq $1 $3; 
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = TBool;
            $$.err = checkRelOp $1.aType $3.aType $1.err $3.err $2;
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = ( (fst $3.indexNew) + 1, snd $3.indexNew );
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $1.tac++$3.tac++
                     case ($1.aType,$3.aType) of {
                          (TFloat,TInt) -> [BinOp "notEqTo_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                          (TFloat,TBool) -> [BinOp "notEqTo_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                          (TInt,TFloat) -> [BinOp "notEqTo_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                          (TInt,TBool) -> [BinOp "notEqTo_int" $$.tacId $1.tacId ("(int)"++$3.tacId)];
                          (TBool,TFloat) -> [BinOp "notEqTo_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                          (TBool,TInt) -> [BinOp "notEqTo_int" $$.tacId ("(int)"++$1.tacId) $3.tacId];
                          (x,_) -> [BinOp ("notEqTo_"++(showType x)) $$.tacId $1.tacId $3.tacId];
                     };
            $$.tacJ = $$.tac;
            where case checkRelOp $1.aType $3.aType $1.err $3.err $2 of {
                       "" -> Ok ();
                       x  -> Bad x;               
                  };
            }

     | RExp '<' RExp {
            $$ = ExpLt $1 $3; 
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = TBool;
            $$.err = checkRelOp $1.aType $3.aType $1.err $3.err $2;
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = ( (fst $3.indexNew) + 1, snd $3.indexNew );
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $1.tac++$3.tac++
                     case ($1.aType,$3.aType) of {
                          (TFloat,TInt) -> [BinOp "lessThan_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                          (TFloat,TBool) -> [BinOp "lessThan_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                          (TInt,TFloat) -> [BinOp "lessThan_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                          (TInt,TBool) -> [BinOp "lessThan_int" $$.tacId $1.tacId ("(int)"++$3.tacId)];
                          (TBool,TFloat) -> [BinOp "lessThan_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                          (TBool,TInt) -> [BinOp "lessThan_int" $$.tacId ("(int)"++$1.tacId) $3.tacId];
                          (x,_) -> [BinOp ("lessThan_"++(showType x)) $$.tacId $1.tacId $3.tacId];
                     };
            $$.tacJ = $$.tac;
            where case checkRelOp $1.aType $3.aType $1.err $3.err $2 of {
                       "" -> Ok ();
                       x  -> Bad x;               
                  };
            }

     | RExp '<=' RExp {
            $$ = ExpLtE $1 $3; 
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = TBool;
            $$.err = checkRelOp $1.aType $3.aType $1.err $3.err $2;
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = ( (fst $3.indexNew) + 1, snd $3.indexNew );
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $1.tac++$3.tac++
                     case ($1.aType,$3.aType) of {
                          (TFloat,TInt) -> [BinOp "lessThanEq_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                          (TFloat,TBool) -> [BinOp "lessThanEq_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                          (TInt,TFloat) -> [BinOp "lessThanEq_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                          (TInt,TBool) -> [BinOp "lessThanEq_int" $$.tacId $1.tacId ("(int)"++$3.tacId)];
                          (TBool,TFloat) -> [BinOp "lessThanEq_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                          (TBool,TInt) -> [BinOp "lessThanEq_int" $$.tacId ("(int)"++$1.tacId) $3.tacId];
                          (x,_) -> [BinOp ("lessThanEq_"++(showType x)) $$.tacId $1.tacId $3.tacId];
                     };
            $$.tacJ = $$.tac;
            where case checkRelOp $1.aType $3.aType $1.err $3.err $2 of {
                       "" -> Ok ();
                       x  -> Bad x;               
                };
            }

     | RExp '>' RExp {
            $$ = ExpGt $1 $3; 
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = TBool;
            $$.err = checkRelOp $1.aType $3.aType $1.err $3.err $2;
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = ( (fst $3.indexNew) + 1, snd $3.indexNew );
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $1.tac++$3.tac++
                     case ($1.aType,$3.aType) of {
                          (TFloat,TInt) -> [BinOp "greaterThan_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                          (TFloat,TBool) -> [BinOp "greaterThan_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                          (TInt,TFloat) -> [BinOp "greaterThan_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                          (TInt,TBool) -> [BinOp "greaterThan_int" $$.tacId $1.tacId ("(int)"++$3.tacId)];
                          (TBool,TFloat) -> [BinOp "greaterThan_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                          (TBool,TInt) -> [BinOp "greaterThan_int" $$.tacId ("(int)"++$1.tacId) $3.tacId];
                          (x,_) -> [BinOp ("greaterThan_"++(showType x)) $$.tacId $1.tacId $3.tacId];
                     };
            $$.tacJ = $$.tac;
            where case checkRelOp $1.aType $3.aType $1.err $3.err $2 of {
                       "" -> Ok ();
                       x  -> Bad x;               
                  };
            }

     | RExp '>=' RExp {
            $$ = ExpGtE $1 $3; 
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = TBool;
            $$.err = checkRelOp $1.aType $3.aType $1.err $3.err $2;
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = ( (fst $3.indexNew) + 1, snd $3.indexNew );
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $1.tac++$3.tac++
                     case ($1.aType,$3.aType) of {
                          (TFloat,TInt) -> [BinOp "greaterThanEq_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                          (TFloat,TBool) -> [BinOp "greaterThanEq_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                          (TInt,TFloat) -> [BinOp "greaterThanEq_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                          (TInt,TBool) -> [BinOp "greaterThanEq_int" $$.tacId $1.tacId ("(int)"++$3.tacId)];
                          (TBool,TFloat) -> [BinOp "greaterThanEq_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                          (TBool,TInt) -> [BinOp "greaterThanEq_int" $$.tacId ("(int)"++$1.tacId) $3.tacId];
                          (x,_) -> [BinOp ("greaterThanEq_"++(showType x)) $$.tacId $1.tacId $3.tacId];
                     };
            $$.tacJ = $$.tac;
            where case checkRelOp $1.aType $3.aType $1.err $3.err $2 of {
                       "" -> Ok ();
                       x  -> Bad x;               
                  };
            }

     | RExp '+' RExp {
            $$ = ExpAdd $1 $3; 
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = if $1.aType == TFloat || $3.aType == TFloat
                         then TFloat
                         else TInt ;
            $$.err = checkAritOp $1.aType $3.aType $1.err $3.err $2;
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = ( (fst $3.indexNew) + 1, snd $3.indexNew );
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $1.tac++$3.tac++
                     (case $$.aType of {
                           TFloat -> if not ($1.aType == TFloat)
                                       then [BinOp "plus_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                                       else if not ($3.aType == TFloat)
                                              then [BinOp "plus_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                                              else [BinOp "plus_float" $$.tacId $1.tacId $3.tacId];
                           TInt   -> if not ($1.aType == TInt)
                                       then [BinOp "plus_int" $$.tacId ("(int)"++$1.tacId) $3.tacId];
                                       else if not ($3.aType == TInt)
                                              then [BinOp "plus_int" $$.tacId $1.tacId ("(int)"++$3.tacId)];
                                              else [BinOp "plus_int" $$.tacId $1.tacId $3.tacId];
                     });
            $$.tacJ = $$.tac;
            where case checkAritOp $1.aType $3.aType $1.err $3.err $2 of {
                       "" -> Ok ();
                       x  -> Bad x;               
                  };
            }

     | RExp '-' RExp {
            $$ = ExpSub $1 $3;
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = if $1.aType == TFloat || $3.aType == TFloat
                         then TFloat
                         else TInt ;
            $$.err = checkAritOp $1.aType $3.aType $1.err $3.err $2;
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = ( (fst $3.indexNew) + 1, snd $3.indexNew );
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $1.tac++$3.tac++
                     case $$.aType of {
                           TFloat -> if not ($1.aType == TFloat)
                                       then [BinOp "minus_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                                       else if not ($3.aType == TFloat)
                                              then [BinOp "minus_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                                              else [BinOp "minus_float" $$.tacId $1.tacId $3.tacId];
                           TInt   -> if not ($1.aType == TInt)
                                       then [BinOp "minus_int" $$.tacId ("(int)"++$1.tacId) $3.tacId];
                                       else if not ($3.aType == TInt)
                                              then [BinOp "minus_int" $$.tacId $1.tacId ("(int)"++$3.tacId)];
                                              else [BinOp "minus_int" $$.tacId $1.tacId $3.tacId];
                     };
            $$.tacJ = $$.tac;
            where case checkAritOp $1.aType $3.aType $1.err $3.err $2 of {
                       "" -> Ok ();
                       x  -> Bad x;
                  };
            }

     | RExp '*' RExp {
            $$ = ExpMul $1 $3; 
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = if $1.aType == TFloat || $3.aType == TFloat
                         then TFloat
                         else TInt ;
            $$.err = (checkAritOp $1.aType $3.aType $1.err $3.err $2);
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = ( (fst $3.indexNew) + 1, snd $3.indexNew );
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $1.tac++$3.tac++
                     (case $$.aType of {
                           TFloat -> if not ($1.aType == TFloat)
                                       then [BinOp "times_float" $$.tacId ("(float)"++$1.tacId) $3.tacId];
                                       else if not ($3.aType == TFloat)
                                              then [BinOp "times_float" $$.tacId $1.tacId ("(float)"++$3.tacId)];
                                              else [BinOp "times_float" $$.tacId $1.tacId $3.tacId];
                           TInt   -> if not ($1.aType == TInt)
                                       then [BinOp "times_int" $$.tacId ("(int)"++$1.tacId) $3.tacId];
                                       else if not ($3.aType == TInt)
                                              then [BinOp "times_int" $$.tacId $1.tacId ("(int)"++$3.tacId)];
                                              else [BinOp "times_int" $$.tacId $1.tacId $3.tacId];
                     });
            $$.tacJ = $$.tac;
            where case checkAritOp $1.aType $3.aType $1.err $3.err $2 of {
                       "" -> Ok ();
                       x  -> Bad x;
                  };
            }

     | RExp '/' RExp {
            $$ = ExpDiv $1 $3; 
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = TFloat ;
            $$.err = checkAritOp $1.aType $3.aType $1.err $3.err $2;
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = ( (fst $3.indexNew) + 1, snd $3.indexNew );
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $1.tac++$3.tac++
                     if not ($1.aType == TFloat) && not ($3.aType == TFloat)
                       then [BinOp "div" $$.tacId ("(float)"++$1.tacId) ("(float)"++$3.tacId)]
                       else if not ($1.aType == TFloat)
                              then [BinOp "div" $$.tacId ("(float)"++$1.tacId) $3.tacId]
                              else if not ($3.aType == TFloat)
                                     then [BinOp "div" $$.tacId $1.tacId ("(float)"++$3.tacId)]
                                     else [BinOp "div" $$.tacId $1.tacId $3.tacId];
            $$.tacJ = $$.tac;
            where case checkAritOp $1.aType $3.aType $1.err $3.err $2 of {
                       "" -> Ok ();
                       x  -> Bad x;
                  };
            }

     | RExp '%' RExp {
            $$ = ExpMod $1 $3; 
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = TInt;
            $$.err = (checkAritOp $1.aType $3.aType $1.err $3.err $2);
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = ( (fst $3.indexNew) + 1, snd $3.indexNew );
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $1.tac++$3.tac++
                     if $1.aType == TBool && $3.aType == TBool
                       then [BinOp "mod" $$.tacId ("(int)"++$1.tacId) ("(int)"++$3.tacId)]
                       else if $1.aType == TBool
                              then [BinOp "mod" $$.tacId ("(int)"++$1.tacId) $3.tacId]
                              else if $3.aType == TBool
                                     then [BinOp "mod" $$.tacId $1.tacId ("(int)"++$3.tacId)]
                                     else [BinOp "mod" $$.tacId $1.tacId $3.tacId];
            $$.tacJ = $$.tac;
            where case checkModOp $1.aType $3.aType $1.err $3.err $2 of {
                       "" -> Ok ();
                       x  -> Bad x;
                  };
            }

     | '-' RExp %prec NEG {
            $$ = ExpNeg $2; 
            $2.envVar = $$.envVar;
            $2.envFun = $$.envFun;
            $$.aType = $2.aType;
            $$.err = if $2.err == ""
                       then if not $ $2.aType == TBool || $2.aType == TInt || $2.aType == TFloat
                              then "Type error at "++(pos $1)++": expected numeric type (or boolean)"
                              else ""
                       else $2.err;
            $2.index = $$.index;
            $$.indexNew = ( (fst $2.indexNew) + 1, snd $2.indexNew );
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $2.tac++[UnOp "neg" $$.tacId $2.tacId];
            $$.tacJ = $$.tac;
            where if $2.err == ""
                    then Ok ()
                    else Bad $2.err ;
            }

     | '&' LExp {
            $$ = ExpRef $2;
            $2.envVar = $$.envVar;
            $2.envFun = $$.envFun;
            $$.aType = TPointer $2.aType;
            $$.err = $2.err;
            $2.index = $$.index;
            $$.indexNew = ( (fst $2.indexNew) + 1, snd $2.indexNew );
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $2.tac++[NulOp $$.tacId ("&"++$2.tacId)];
            $$.tacJ = $$.tac;
            }

     | Id '(' ')' {
            $$ = ExpFuncEmpty $1; 
            $$.aType = getTypeFun $ extractFun $1 $$.envFun;   
            $$.err = checkCallProc $1 $$.envFun [] $2;
            $$.indexNew = if $$.aType==TVoid
                            then $$.index
                            else ( (fst $$.index) + 1, snd $$.index );
            $1.tacId = (idToStr $1)++getPosF $1 $$.envFun;
            $$.tacId = if $$.aType==TVoid
                         then ""
                         else "t"++(show $ fst $$.indexNew);
            $$.tac = if $$.aType==TVoid
                       then [FunCall 'p' "" (Id $1.tacId) []]
                       else [FunCall 'f' $$.tacId (Id $1.tacId) []];
            $$.tacJ = $$.tac;
            where case checkCallProc $1 $$.envFun [] $2 of {
                       "" -> Ok ();
                       x  -> Bad x;
                  }; 
            }

     | Id '(' ListRExp ')' {
            $$ = ExpFunc $1 $3; 
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = getTypeFun $ extractFun $1 $$.envFun;
            $$.err = checkCallFun $3.err $1 $$.envFun $3.aTypeList $2;
            $3.index = $$.index;
            $$.indexNew = if $$.aType==TVoid
                            then $3.indexNew
                            else ( (fst $3.indexNew) + 1, snd $3.indexNew );
            $1.tacId = (idToStr $1)++getPosF $1 $$.envFun;
            $$.tacId = if $$.aType==TVoid
                         then ""
                         else "t"++(show $ fst $$.indexNew);
            $$.tac = if $$.aType==TVoid
                       then $3.tac++[FunCall 'p' "" (Id $1.tacId) (paramCast $1 $$.envFun $3.aTypeList $3.tacIdList)]
                       else $3.tac++[FunCall 'f' $$.tacId (Id $1.tacId) (paramCast $1 $$.envFun $3.aTypeList $3.tacIdList)];
            $$.tacJ = $$.tac;
            where case checkCallFun $3.err $1 $$.envFun $3.aTypeList $2 of {
                       "" -> Ok ();
                       x  -> Bad x;
                  };
            }

     | Val {
            $$ = ExpVal $1;
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $$.aType = $1.aType;
            $$.err = "";
            $$.indexNew = $$.index;
            $$.tacId = showVal $1;
            $$.tac = [];
            $$.tacJ = [];
            }

     | LExp {
            $$ = ExpLExp $1;
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $$.aType = $1.aType;
            $$.err = $1.err;
            $1.index = $$.index;
            $$.indexNew = $1.indexNew;
            $$.tacId = $1.tacId;
            $$.tac = $1.tac;
            $$.tacJ = $$.tac;
            }

     | '(' RExp ')' {
            $$ = ExpPar $2; 
            $2.envVar = $$.envVar;
            $2.envFun = $$.envFun;
            $$.aType = $2.aType;
            $$.err = $2.err;
            $2.index = $$.index;
            $$.indexNew = $2.indexNew;
            $$.tacId = $2.tacId;
            $$.tac = $2.tac;
            $$.tacJ = $$.tac;
            }

     | 'readInt' '(' ')' {
                $$ = StRead ReadT_readInt;
                $$.aType = TInt;
                $$.aReturn = False;
                $$.indexNew = ((fst $$.index)+1,snd $$.index);
                $$.err = "";
                $$.tacId = "t"++(show $ fst $$.indexNew);
                $$.tac = [FunCall 'f' $$.tacId (Id "readInt") []];
                $$.tacJ = $$.tac;
                }

     | 'readFloat' '(' ')' {
                $$ = StRead ReadT_readFloat;
                $$.aType = TFloat;
                $$.aReturn = False;
                $$.indexNew = ((fst $$.index)+1,snd $$.index);
                $$.err = "";
                $$.tacId = "t"++(show $ fst $$.indexNew);
                $$.tac = [FunCall 'f' $$.tacId (Id "readFloat") []];
                $$.tacJ = $$.tac;
                }

     | 'readChar' '(' ')' {
                $$ = StRead ReadT_readChar;
                $$.aType = TChar;
                $$.aReturn = False;
                $$.indexNew = ((fst $$.index)+1,snd $$.index);
                $$.err = "";
                $$.tacId = "t"++(show $ fst $$.indexNew);
                $$.tac = [FunCall 'f' $$.tacId (Id "readChar") []];
                $$.tacJ = $$.tac;
                }

     | 'readString' '(' ')' {
                $$ = StRead ReadT_readString;
                $$.aType = TString;
                $$.aReturn = False;
                $$.indexNew = ((fst $$.index)+1,snd $$.index);
                $$.err = "";
                $$.tacId = "t"++(show $ fst $$.indexNew);
                $$.tac = [FunCall 'f' $$.tacId (Id "readString") []];
                $$.tacJ = $$.tac;
                }

Val : Integer {
        $$ = Int $1; 
        $$.aType = TInt;
        } 

    | Double {
        $$ = Float $1; 
        $$.aType = TFloat;
        }

    | Char {
        $$ = Char $1; 
        $$.aType = TChar;
        }

    | String {
        $$ = String $1; 
        $$.aType = TString;
        }

    | Boolean {
        $$ = Bool $1; 
        $$.aType = TBool;
        }

LExp : Id {
            $$ = ExpId $1; 
            $$.aType = getTypeVar $ extractVar $1 $$.envVar;
            $$.err = if not $ searchVar $1 $$.envVar
                       then "Error : variable  "++(idToStr $1)++" not in scope"
                       else "";
            $$.indexNew = $$.index;
            $$.tacId = (idToStr $1)++(getPosV $1 $$.envVar);
            $$.tac = [];
            where if not $ searchVar $1 $$.envVar
                    then Bad $ "Error : variable  "++(idToStr $1)++" not in scope"
                    else Ok () ;
            }

     | LExp '[' RExp ']' {
            $$ = ExpArr $1 $3; 
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aType = getTypeArr $1.aType;
            $$.err = if $1.err == "" && $3.err == ""
                       then case $1.aType of { 
                                 TArray _ _  -> if not $ $3.aType == TInt
                                                  then "Type error at "++(pos $2)++": expected int, "++showType ($3.aType)++" found"
                                                  else "" ;
                                 otherwise   -> "Type error at "++(pos $2)++": expected array, "++showType ($1.aType)++" found" ;
                            }
                       else if $1.err ==""
                              then $3.err
                              else $1.err ; 
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = ((fst $3.indexNew)+1, snd $3.indexNew);
            $$.tacId = $1.tacId++"[t"++(show $ (fst $3.indexNew) +1)++"]";
            $$.tac = $1.tac++$3.tac++[BinOp "*" ("t"++(show $ (fst $3.indexNew) +1)) $3.tacId (show $ size $$.aType)];
            where if $1.err == "" && $3.err == ""
                    then case $1.aType of { 
                              TArray _ _  -> if not $ $3.aType == TInt 
                                               then Bad $ "Type error at "++(pos $2)++": expected int, "++showType ($3.aType)++" found"
                                               else Ok () ;
                              otherwise   -> Bad $ "Type error at "++(pos $2)++": expected array, "++showType ($1.aType)++" found" ;
                         }
                    else if $1.err ==""
                           then Bad $3.err
                           else Bad $1.err; 
            }

     | '*' RExp %prec PTR {
            $$ = ExpDeref $2; 
            $2.envVar = $$.envVar;
            $2.envFun = $$.envFun;
            $$.aType = getTypePtr $2.aType;
            $$.err = if $2.err ==""
                       then if not $ isTypePtr $2.aType 
                              then "Type error at "++(pos $1)++": expected pointer, "++showType ($2.aType)++" found"
                              else ""
                       else $2.err ;
            $2.index = $$.index;
            $$.indexNew = ( (fst $2.indexNew) + 1, snd $2.indexNew);
            $$.tacId = "t"++(show $ fst $$.indexNew);
            $$.tac = $2.tac++[NulOp $$.tacId ("*"++$2.tacId)];
            where if $2.err ==""
                    then if not $ isTypePtr $2.aType
                           then Bad $ "Type error at "++(pos $1)++": expected pointer, "++showType ($2.aType)++" found"
                           else Ok ()
                    else Bad $2.err ;
            }

Start : 'package' Id ListDecl {
                    $$ = (Entry $2 (reverse $3), $$.tac);
                    $$.envVar = [];
                    $$.envFun = [];
                    $3.envVar = $$.envVar;
                    $3.envFun = $$.envFun;
                    $$.aType = TInt;
                    $3.index = (0,0);
                    $$.tac = $3.tac;
                    }

Decl : 'var' ListId Type {
                        $$ = DeclVar $2 $3;
                        $$.envVarNew = unionVar (createListType $2 $3 (pos $1)) $$.envVar;
                        $$.envFunNew = $$.envFun;
                        $$.idList = setPos $2 (pos $1);
                        $$.indexNew = $$.index;
                        $$.tac = [] ;
                        where case checkSameBlockList $$.idList $$.envVar of {
                                   Just a  -> Bad $ "Error at "++(pos $1)++": variable "++(idToStr a)++" already declared" ;
                                   Nothing -> Ok () ;
                              };
                        }

     | 'var' ListId '=' ListRExp {
                        $$ = DeclVarInit $2 $4;
                        $4.envVar = $$.envVar;
                        $4.envFun = $$.envFun;                              
                        $$.envVarNew = unionVar (createListTypes $2 $4.aTypeList (pos $1)) $$.envVar;
                        $$.envFunNew = $$.envFun;
                        $$.idList = setPos $2 (pos $1);
                        $4.index = $$.index;
                        $$.indexNew = $4.indexNew;
                        $$.tac = $4.tac++(tacAssign $$.idList $4.tacIdList);
                        where case checkSameBlockList $2 $$.envVar of {
                                   Just  a -> Bad $ "Error at "++(pos $1)++": variable "++(idToStr a)++" already declared";
                                   Nothing -> if not $ length $2 == length $4.aTypeList
                                                then Bad $ "Error at "++(pos $1)++": number of variables and number of expressions don't match"
                                                else Ok () ;
                              };
                        }
                        
     | 'var' ListId Type '=' ListRExp {
                        $$ = DeclVarTypeInit $2 $3 $5;
                        $5.envVar = $$.envVar;
                        $5.envFun = $$.envFun;                              
                        $$.envVarNew = unionVar (createListType $2 $3 (pos $1)) $$.envVar;
                        $$.envFunNew = $$.envFun;
                        $$.idList = setPos $2 (pos $1);
                        $5.index = $$.index;
                        $$.indexNew = $5.indexNew;
                        $$.tac = $5.tac++(tacAssignCast $$.idList $5.tacIdList $3 $5.aTypeList);
                        where case checkSameBlockList $2 $$.envVar of {
                                   Just a  -> Bad $ "Error at "++(pos $1)++": variable "++(idToStr a)++" already declared";
                                   Nothing -> if not $ length $2 == length $5.aTypeList
                                                then Bad $ "Error at "++(pos $1)++": number of variables and number of expressions don't match"
                                                else case checkTypes $3 ($5.aTypeList) of {
                                                          Just a  -> Bad $ "Type error at "++(pos $4)++": cannot use "++(showType $ snd a)++" as "++(showType $ fst a)++" in assignment";
                                                          Nothing -> Ok () ;
                                                     };
                              };
                        }

     | 'func' Id '(' ListParam ')' Type Block {
                        $$ = DeclFun $2 $4 $6 $7;
                        $$.envVarNew = $$.envVar;
                        $$.envFunNew = insertFun (Fun $2 $6 $4.aTypeList (pos $1)) $$.envFun;
                        $7.envVar = unionVar $4.envVar (resetEnvVar $$.envVar);
                        $7.envFun = $$.envFunNew;
                        $$.idList = setPos [$2] (pos $1);
                        $7.aTypeFun = $6;
                        $7.forLabels = (-1,-1);
                        $7.index = $$.index;
                        $$.indexNew = ( fst $7.indexNew, (snd $7.indexNew) + 1 );
                        $$.tac = [FunDecl "function" (Id $ idToStr $ head $$.idList) (length $4.aTypeList)]++$7.tac++[Lbl $ (snd $7.indexNew)+1] ;
                        where if searchFun $2 $$.envFun
                                then Bad $ "Error at "++(pos $1)++": function "++(idToStr $2)++" already declared"
                                else when (not $7.aReturn) $ Bad $ "Error at "++(pos $1)++": missing return at end of function" ;
                        }

     | 'func' Id '(' ListParam ')' 'void' Block {
                        $$ = DeclProc $2 $4 $7;
                        $$.envVarNew = $$.envVar;
                        $$.envFunNew = insertFun (Fun $2 TVoid $4.aTypeList (pos $1)) $$.envFun;
                        $7.envVar = unionVar $4.envVar (resetEnvVar $$.envVar); 
                        $7.envFun = $$.envFunNew;
                        $$.idList = setPos [$2] (pos $1);
                        $7.aTypeFun = TVoid;
                        $7.forLabels = (-1,-1);
                        $7.index = $$.index;
                        $$.indexNew = ( fst $7.indexNew, (snd $7.indexNew) + 1 );
                        $$.tac = [FunDecl "procedure" (Id $ idToStr $ head $$.idList) (length $4.aTypeList)]++$7.tac++[Lbl $ (snd $7.indexNew) + 1] ;
                        where if searchFun $2 $$.envFun
                                then Bad $ "Error at "++(pos $1)++": procedure "++(idToStr $2)++" already declared"
                                else Ok () ;
                        }

ShortVarDecl : ListId ':=' ListRExp {
                        $$ = DeclVarShort $1 $3;
                        $3.envVar = $$.envVar;
                        $3.envFun = $$.envFun;
                        $$.envVarNew = unionVar (createListTypes $1 $3.aTypeList (pos $2)) $$.envVar;
                        $$.envFunNew = $$.envFun;
                        $$.idList = setPos $1 (pos $2);
                        $3.index = $$.index;
                        $$.indexNew = $3.indexNew;
                        $$.tac = $3.tac++(tacAssign $$.idList $3.tacIdList);
                        where case checkSameBlockList $1 $$.envVar of {
                                   Just a -> Bad $ "Error at "++(pos $2)++": variable "++(idToStr a)++" already declared";
                                   Nothing -> if not $ length $1 == length $3.aTypeList
                                                then Bad $ "Error at "++(pos $2)++": number of variables and number of expressions don't match"
                                                else Ok () ;
                              };
                        }

Param : ListId Type {
                  $$ = Parameter $1 $2; 
                  $$.envVar = createListType $1 $2 $2.posi;
                  $$.aTypeList = replicate (length $1) $2;
                  }

      | Pass ListId Type {
                  $$ = ParameterPass $1 $2 $3; 
                  $$.envVar = if $1 == PassRef
                                then createListType $2 $3 $3.posi
                                else createListType $2 $3 $3.posi;
                  $$.aTypeList = replicate (length $2) $3;
                  }

Block : '{' ListStmt '}' {
                    $$ = BodyBlock $ reverse $2; 
                    $2.envVar = $$.envVar;
                    $2.envFun = $$.envFun;
                    $$.envVarNew = $$.envVar;
                    $$.envFunNew = $$.envFun;
                    $2.aTypeFun = $$.aTypeFun;
                    $$.aReturn = $2.aReturn;
                    $2.forLabels = $$.forLabels;
                    $2.index = $$.index;
                    $$.indexNew = $2.indexNew;
                    $$.tac = $2.tac;
                    }

Stmt : Decl {
              $$ = StDecl $1; 
              $1.envVar = $$.envVar;
              $1.envFun = $$.envFun;
              $$.envVarNew = $1.envVarNew;
              $$.envFunNew = $1.envFunNew;
              $$.aReturn = False;
              $1.index = $$.index;
              $$.indexNew = $1.indexNew;                    
              $$.tac = $1.tac;
              }

     | Block {
              $$ = StBlock $1; 
              $1.envVar = resetEnvVar $$.envVar;
              $1.envFun = $$.envFun;
              $$.envVarNew = $$.envVar;
              $$.envFunNew = $$.envFun;
              $1.aTypeFun = $$.aTypeFun;
              $$.aReturn = False;
              $1.forLabels = $$.forLabels;
              $1.index = $$.index;
              $$.indexNew = $1.indexNew;
              $$.tac = $1.tac;
              }

     | StmtSmpl {
              $$ = StSmpl $1; 
              $1.envVar = $$.envVar;
              $1.envFun = $$.envFun;
              $$.envVarNew = $1.envVarNew;
              $$.envFunNew = $1.envFunNew;
              $$.aReturn = False;
              $1.index = $$.index;
              $$.indexNew = $1.indexNew;
              $$.tac = $1.tac;
              }

     | 'if' RExp Block {
                    $$ = StIf $2 $3; 
                    $2.envVar = $$.envVar;
                    $2.envFun = $$.envFun;
                    $3.envVar = resetEnvVar $$.envVar;
                    $3.envFun = $$.envFun;
                    $$.envVarNew = $$.envVar;
                    $$.envFunNew = $$.envFun;
                    $3.aTypeFun = $$.aTypeFun;
                    $$.aReturn = False;
                    $3.forLabels = $$.forLabels;
                    $2.index = $$.index;
                    $3.index = $2.indexNew;
                    $$.indexNew = ( fst $3.indexNew, (snd $3.indexNew) + 2 );
                    $$.tac = shift $2.tacJ (snd $3.indexNew)
                           ++[CondJFalse $2.tacId ((snd $3.indexNew)+2)]
                           ++[Lbl $ (snd $3.indexNew) + 1]
                           ++$3.tac
                           ++[Lbl $ (snd $3.indexNew) + 2];
                    where if $2.err == ""
                            then when (not $ $2.aType == TBool) $ Bad $ "Type error at "++(pos $1)++": type "++(showType $2.aType) ++" used as condition (if)"
                            else Bad $2.err ;
                    }

     | 'if' RExp Block 'else' Block {
                    $$ = StIfElse $2 $3 $5;
                    $2.envVar = $$.envVar;
                    $2.envFun = $$.envFun;
                    $3.envVar = resetEnvVar $$.envVar;
                    $3.envFun = $$.envFun;
                    $5.envVar = resetEnvVar $$.envVar;
                    $5.envFun = $$.envFun;
                    $$.envVarNew = $$.envVar;
                    $$.envFunNew = $$.envFun;
                    $3.aTypeFun = $$.aTypeFun;
                    $5.aTypeFun = $$.aTypeFun;
                    $$.aReturn = False;
                    $3.forLabels = $$.forLabels;
                    $5.forLabels = $$.forLabels;
                    $2.index = $$.index;
                    $3.index = $2.indexNew;
                    $5.index = $3.indexNew;
                    $$.indexNew = ( fst $5.indexNew, (snd $5.indexNew) + 3);
                    $$.tac = shift $2.tacJ (snd $5.indexNew)
                           ++[CondJFalse $2.tacId ((snd $5.indexNew)+2)]
                           ++[Lbl $ (snd $5.indexNew) + 1]
                           ++$3.tac
                           ++[UncondJ $ (snd $5.indexNew) + 3]
                           ++[Lbl $ (snd $5.indexNew) + 2]
                           ++$5.tac
                           ++[Lbl $ (snd $5.indexNew) + 3];
                    where if $2.err == ""
                            then when (not $ $2.aType == TBool) $ Bad $ "Type error at "++(pos $1)++": type "++(showType $2.aType) ++" used as condition (if)"
                            else Bad $2.err ;
                    }

     | 'for' RExp Block {
                $$ = StWhile $2 $3;
                $2.envVar = $$.envVar;
                $2.envFun = $$.envFun;
                $3.envVar = resetEnvVar $$.envVar;
                $3.envFun = $$.envFun;
                $$.envVarNew = $$.envVar;
                $$.envFunNew = $$.envFun;
                $3.aTypeFun = $$.aTypeFun;
                $$.aReturn = False;
                $3.forLabels = ( (snd $3.indexNew) + 1, (snd $3.indexNew) + 3 );
                $2.index = $$.index;
                $3.index = $2.indexNew;                   
                $$.indexNew = ( fst $3.indexNew, (snd $3.indexNew) + 3 );
                $$.tac = [Lbl $ (snd $3.indexNew) + 1]
                       ++shift $2.tacJ (snd $3.indexNew + 1)
                       ++[CondJFalse $2.tacId ((snd $3.indexNew) + 3)]
                       ++[Lbl $ (snd $3.indexNew) + 2]
                       ++$3.tac
                       ++[UncondJ $ (snd $3.indexNew) + 1]
                       ++[Lbl $ (snd $3.indexNew) + 3];
                where if $2.err == ""
                        then when (not $ $2.aType == TBool) $ Bad $ "Type error at "++(pos $1)++": type "++(showType $2.aType) ++" used as condition (for)"
                        else Bad $2.err ;
                }

     | 'do' Block 'for' RExp {
                $$ = StDoWhile $2 $4;
                $4.envVar = $$.envVar;
                $4.envFun = $$.envFun;
                $2.envVar = resetEnvVar $$.envVar;
                $2.envFun = $$.envFun;
                $$.envVarNew = $$.envVar;
                $$.envFunNew = $$.envFun;
                $2.aTypeFun = $$.aTypeFun;
                $$.aReturn = False;
                $2.forLabels = ( (snd $2.indexNew) + 1, (snd $2.indexNew) + 2 );
                $4.index = $$.index;
                $2.index = $4.indexNew;                   
                $$.indexNew = ( fst $2.indexNew, (snd $2.indexNew) + 2 );
                $$.tac = [Lbl $ (snd $2.indexNew) + 1]
                       ++$2.tac
                       ++shift $4.tacJ (snd $2.indexNew + 1)
                       ++[CondJTrue $4.tacId ((snd $2.indexNew) + 1)]
                       ++[Lbl $ (snd $2.indexNew) + 2];
                where if $4.err == ""
                        then when (not $ $4.aType == TBool) $ Bad $ "Type error at "++(pos $1)++": type "++(showType $4.aType) ++" used as condition (for)"
                        else Bad $4.err ;
                }

     | 'for' ListStmtSmpl ';' RExp ';' ListStmtSmpl Block 	{ 
									$$ = StFor $2 $4 $6 $7; 
									$2.envVar = (resetEnvVar $$.envVar);
									$2.envFun = $$.envFun;
									$4.envVar = $2.envVarNew;
									$4.envFun = $2.envFunNew;
									$5.envVar = $2.envVarNew;
									$5.envFun = $2.envFunNew;
									$6.envVar = $2.envVarNew;
									$6.envFun = $2.envFunNew;
									$7.envVar = resetEnvVar $2.envVarNew;
									$7.envFun = $6.envFunNew;
									$$.envVarNew = $$.envVar;
									$$.envFunNew = $$.envFun;
									$7.aTypeFun = $$.aTypeFun;
									$$.aReturn = False;
									$7.forLabels = ( (snd $7.indexNew)+1, (snd $7.indexNew)+2 );
									$2.index = $$.index;
									$4.index = $2.indexNew;
									$6.index = $4.indexNew;
									$7.index = $6.indexNew;
									$$.indexNew = ( fst $7.indexNew, (snd $7.indexNew)+2 );
									$$.tac = $2.tac ++ [Lbl $ (snd $7.indexNew)+1] 
                        ++ $4.tac
                        ++ [CondJFalse $4.tacId ((snd $7.indexNew)+2)] 
                        ++ $7.tac
                        ++ $6.tac
                        ++ [UncondJ $ (snd $7.indexNew)+1] 
                        ++ [Lbl $ (snd $7.indexNew)+2];
									where if $4.err == ""
                          then if $4.aType == TBool
                                 then Ok ()
                                 else Bad $ "Type error at "++(pos $1)++": type "++ (showType $4.aType) ++" used condition (for)"
                          else Bad $4.err ;
									}

     | 'break' {
                $$ = StBreak; 
                $$.envVarNew = $$.envVar;
                $$.envFunNew = $$.envFun;
                $$.aReturn = False;
                $$.indexNew = $$.index;
                $$.tac = [UncondJ $ snd $$.forLabels];                 
                where when ( fst $$.forLabels == (-1) ) $ Bad $ "Error at "++(pos $1)++": 'break' instruction outside of a loop" ;
                }

     | 'continue' {
                $$ = StContinue;
                $$.envVarNew = $$.envVar;
                $$.envFunNew = $$.envFun;
                $$.aReturn = False;
                $$.indexNew = $$.index;
                $$.tac = [UncondJ $ fst $$.forLabels];             
                where when ( fst $$.forLabels == (-1) ) $ Bad $ "Error at "++(pos $1)++": 'continue' instruction outside of a loop" ;
                }

     | 'return' RExp {
                    $$ = StReturn $2; 
                    $2.envVar = $$.envVar;
                    $2.envFun = $$.envFun;
                    $$.envVarNew = $$.envVar;
                    $$.envFunNew = $$.envFun;
                    $$.aReturn = True;
                    $2.index = $$.index;
                    $$.indexNew = $2.indexNew;
                    $$.tac = $2.tac++[Return $2.tacId];
                    where if $2.err == ""
                            then case $$.aTypeFun of {
                                      TVoid -> Bad $ "Error at "++(pos $1)++": procedures can't return any value" ;
                                      _ -> when (not $ $2.aType == $$.aTypeFun) $ Bad $ "Type error at "++(pos $1)++": cannot use "++(showType $2.aType)++" as "++(showType $$.aTypeFun)++" in return instruction" ;

                                 }
                            else Bad $2.err ;
                    }

     | 'try' Stmt 'catch' Stmt 	{ 
          $$ = StTryCatch $2 $4;
          $2.envVar = (resetEnvVar $$.envVar);
          $2.envFun = $$.envFun;
          $4.envVar = (resetEnvVar $$.envVar);
          $4.envFun = $$.envFun; 
          $$.envVarNew = $$.envVar;
          $$.envFunNew = $$.envFun;
          $2.aTypeFun = $$.aTypeFun;
          $4.aTypeFun = $$.aTypeFun;
          $$.aReturn = False;
          $2.forLabels = $$.forLabels;
          $4.forLabels = $$.forLabels;
          $2.index = $$.index;
          $4.index = $2.indexNew;					
          $$.indexNew = ( (fst $4.indexNew) , ((snd $4.indexNew)+2) );
          $$.tac = $2.tac
                 ++[ExcpJ ((snd $4.indexNew)+1)]
                 ++ [UncondJ ((snd $4.indexNew)+2)] 
                 ++ [Lbl ((snd $4.indexNew)+1)]
                 ++ $4.tac 
                 ++ [Lbl ((snd $4.indexNew)+2)];
          }

     | 'writeInt' '(' RExp ')' {
                    $$ = StWrite WriteT_writeInt $3;
                    $3.envVar = $$.envVar;
                    $3.envFun = $$.envFun;
                    $$.envVarNew = $$.envVar;
                    $$.envFunNew = $$.envFun;
                    $$.aReturn = False;
                    $3.index = $$.index;
                    $$.indexNew = $3.indexNew;
                    $$.tac = $3.tac++[FunCall 'p' "" (Id "writeInt") [$3.tacId]];
                    where if $3.err == ""
                            then when ( not $ $3.aType == TInt ) $ Bad $ "Type error at "++(pos $2)++": needed integer parameter when using writeInt"
                            else Bad $3.err ;
                    }

     | 'writeFloat' '(' RExp ')' {
                    $$ = StWrite WriteT_writeFloat $3;
                    $3.envVar = $$.envVar;
                    $3.envFun = $$.envFun;
                    $$.envVarNew = $$.envVar;
                    $$.envFunNew = $$.envFun;
                    $$.aReturn = False;
                    $3.index = $$.index;
                    $$.indexNew = $3.indexNew;
                    $$.tac = $3.tac++[FunCall 'p' "" (Id "writeFloat") [$3.tacId]];
                    where if $3.err == ""
                        then when ( not $ $3.aType == TFloat ) $ Bad $ "Type error at "++(pos $2)++": needed float parameter when using writeFloat"
                        else Bad $3.err ;
                    }

     | 'writeChar' '(' RExp ')' {
                    $$ = StWrite WriteT_writeChar $3;
                    $3.envVar = $$.envVar;
                    $3.envFun = $$.envFun;
                    $$.envVarNew = $$.envVar;
                    $$.envFunNew = $$.envFun;
                    $$.aReturn = False;
                    $3.index = $$.index;
                    $$.indexNew = $3.indexNew;
                    $$.tac = $3.tac++[FunCall 'p' "" (Id "writeChar") [$3.tacId]];
                    where if $3.err == ""
                        then when ( not $ $3.aType == TChar ) $ Bad $ "Type error at "++(pos $2)++": needed char parameter when using writeChar"
                        else Bad $3.err ;
                    }

     | 'writeString' '(' RExp ')' {
                    $$ = StWrite WriteT_writeString $3;
                    $3.envVar = $$.envVar;
                    $3.envFun = $$.envFun;
                    $$.envVarNew = $$.envVar;
                    $$.envFunNew = $$.envFun;
                    $$.aReturn = False;
                    $3.index = $$.index;
                    $$.indexNew = $3.indexNew;
                    $$.tac = $3.tac++[FunCall 'p' "" (Id "writeString") [$3.tacId]];
                    where if $3.err == ""
                        then when ( not $ $3.aType == TString ) $ Bad $ "Type error at "++(pos $2)++": needed string parameter when using writeString"
                        else Bad $3.err ;
                    }

StmtSmpl : ShortVarDecl {
                $$ = StShortVarDecl $1; 
                $1.envVar = $$.envVar;
                $1.envFun = $$.envFun;
                $$.envVarNew = $1.envVarNew;
                $$.envFunNew = $1.envFunNew;
                $1.index = $$.index;
                $$.indexNew = $1.indexNew;
                $$.tac = $1.tac ;
                } 

         | RExp {
                $$ = StExp $1; 
                $1.envVar = $$.envVar;
                $1.envFun = $$.envFun;
                $$.envVarNew = $$.envVar;
                $$.envFunNew = $$.envFun;
                $1.index = $$.index;
                $$.indexNew = $1.indexNew;
                $$.tac = $1.tac;
                where if $1.err == ""
                        then if $1.tacId == ""
                               then Ok ()
                               else Bad "Error : right expression evaluated but not assigned"
                        else Bad $1.err ;
                }

         | LExp '=' RExp {
                $$ = StAsgn $1 $3; 
                $1.envVar = $$.envVar;
                $1.envFun = $$.envFun;
                $3.envVar = $$.envVar;
                $3.envFun = $$.envFun;
                $$.envVarNew = $$.envVar;
                $$.envFunNew = $$.envFun;
                $1.index = $$.index;
                $3.index = $1.indexNew;
                $$.indexNew = ( (fst $3.indexNew)+1, snd $3.indexNew);
                $$.tacId = "t" ++ (show $ fst $$.indexNew);
                $$.tac = $1.tac++$3.tac++
                         if $1.aType == TFloat && not ($3.aType == TFloat)
                           then [NulOp $1.tacId ("(float)"++$3.tacId)]
                           else if $1.aType == TInt && $3.aType == TBool
                                  then [NulOp $1.tacId ("(int)"++$3.tacId)]
                                  else [NulOp $1.tacId $3.tacId];
                where if $1.err == "" && $3.err == ""
                        then if $1.aType == TFloat && $3.aType == TInt
                               then Ok ()
                               else when (not $ $1.aType == $3.aType) $ Bad $ "Type error at "++(pos $2)++": cannot use "++(showType $3.aType)++" as "++(showType $1.aType)++" in assignment"
                        else if not $ $1.err ==""
                               then Bad $ $1.err
                               else Bad $3.err ; 
                }


ListRExp : RExp {
            $$ = [$1];
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $$.aTypeList = [$1.aType];
            $$.err = $1.err;
            $1.index = $$.index;
            $$.indexNew = $1.indexNew;
            $$.tacIdList = [$1.tacId];
            $$.tac = $1.tac;
            } 

         | RExp ',' ListRExp {
            $$ = (:) $1 $3;
            $1.envVar = $$.envVar;
            $1.envFun = $$.envFun;
            $3.envVar = $$.envVar;
            $3.envFun = $$.envFun;
            $$.aTypeList = $1.aType : $3.aTypeList;
            $$.err = $1.err;
            $1.index = $$.index;
            $3.index = $1.indexNew;
            $$.indexNew = $3.indexNew;
            $$.tacIdList = $1.tacId : $3.tacIdList;
            $$.tac = $1.tac++$3.tac;
            }

ListDecl : {- empty -} {
                $$ = [];
                $$.envVarNew = $$.envVar;
                $$.envFunNew = $$.envFun;
                $$.indexNew = $$.index;
                $$.tac = [];
                } 

         | ListDecl Decl {
                $$ = flip (:) $1 $2;
                $1.envVar = $$.envVar;
                $1.envFun = $$.envFun;
                $2.envVar = $1.envVarNew;
                $2.envFun = $1.envFunNew;
                $$.envVarNew = $2.envVarNew;
                $$.envFunNew = $2.envFunNew;
                $1.index = $$.index;
                $2.index = $1.indexNew;
                $$.indexNew = $2.indexNew;
                $$.tac = $1.tac++$2.tac;
                }

ListId : Id {
            $$ = [$1];
            $$.idList = [$1];
            } 

       | Id ',' ListId {
            $$ = (:) $1 $3;
            $$.idList = $1 : $3.idList;
            where when (elem $1 $3) $ Bad $ "Error at "++(pos $2)++": duplicate identifier "++(idToStr $1) ; 
            }

ListParam : {- empty -} {
                    $$ = [];
                    $$.envVar = [];
                    $$.aTypeList = [];
                    } 

          | Param {
                    $$ = [$1];
                    $$.envVar = $1.envVar;
                    $$.aTypeList = $1.aTypeList;            
                    }

          | Param ',' ListParam {
                    $$ = (:) $1 $3;
                    $$.envVar = $1.envVar++$3.envVar;
                    $$.aTypeList = ($1.aTypeList)++($3.aTypeList);
                    where case checkVarParams $1.envVar $3.envVar of {
                               Just a  -> Bad $ "Error at "++(pos $2)++": duplicate identifier "++idToStr a ;
                               Nothing -> Ok () ;
                          };
                    }

ListStmt : {- empty -} {
                        $$ = []; 
                        $$.envVarNew = $$.envVar;
                        $$.envFunNew = $$.envFun;
                        $$.aReturn = False;
                        $$.indexNew = $$.index;
                        $$.tac = [];
                        }
 
         | ListStmt Stmt {
                        $$ = flip (:) $1 $2;
                        $1.envVar = $$.envVar;
                        $1.envFun = $$.envFun;
                        $2.envVar = $1.envVarNew;
                        $2.envFun = $1.envFunNew;
                        $$.envVarNew = $2.envVarNew;
                        $$.envFunNew = $2.envFunNew;
                        $1.aTypeFun = $$.aTypeFun;
                        $2.aTypeFun = $$.aTypeFun;
                        $$.aReturn = $2.aReturn;
                        $1.forLabels = $$.forLabels;
                        $2.forLabels = $$.forLabels;
                        $1.index = $$.index;
                        $2.index = $1.indexNew;
                        $$.indexNew = $2.indexNew;
                        $$.tac = $1.tac++$2.tac;
                        }

ListStmtSmpl : {- empty -} {
                        $$ = [];
                        $$.envVarNew = $$.envVar;
                        $$.envFunNew = $$.envFun;
                        $$.aReturn = False;
                        $$.indexNew = $$.index;
                        $$.tac = [];
                        }

         | StmtSmpl {
                        $$ = [$1];
                        $1.envVar = $$.envVar;
                        $1.envFun = $$.envFun;
                        $$.envVarNew = $1.envVarNew;
                        $$.envFunNew = $1.envFunNew;
                        $1.aTypeFun = $$.aTypeFun;
                        $$.aReturn = $1.aReturn;
                        $1.forLabels = $$.forLabels;
                        $1.index = $$.index;
                        $$.indexNew = $1.indexNew;
                        $$.tac = $1.tac;
                        }





{

-----------------------------------------------------------
-- functions for type checking and other errors handling --
-----------------------------------------------------------

-- checks for arithmetic operations consistency
checkAritOp :: Type -> Type -> [Char] -> [Char] -> Token -> [Char]
checkAritOp t1 t2 e1 e2 op = if e1 == "" && e2 == ""
                               then if (t1 == TBool || t1 == TInt || t1 == TFloat) && (t2 == TBool || t2 == TInt || t2 == TFloat)
                                      then ""
                                      else "Type error at "++(pos op)++": expected numeric type (or boolean)"
                               else if e1/=""
                                      then e1
                                      else e2

-- checks for mod operation consistency
checkModOp :: Type -> Type -> [Char] -> [Char] -> Token -> [Char]
checkModOp t1 t2 e1 e2 op = if e1 == "" && e2 == ""
                              then if (t1 == TBool || t1 == TInt) || (t2 == TBool && t2 == TInt)
                                     then ""
                                     else "Type error at "++(pos op)++": expected int (or bool) as mod operand"
                              else if e1/=""
                                     then e1
                                     else e2

-- checks for relational operations consistency
checkRelOp :: Type -> Type -> [Char] -> [Char] -> Token -> [Char]
checkRelOp t1 t2 e1 e2 op = if (e1 == "") && (e2 == "")
                              then if t1 == t2
                                     then ""
                                     else if (t1 == TBool || t1 == TInt || t1 == TFloat) && (t2 == TBool || t2 == TInt || t2 == TFloat)
                                            then ""
                                            else "Type error at "++(pos op)++": can't match type "++(showType t1)++" with type "++(showType t2)
                              else if e1/=""
                                     then e1
                                     else e2

-- checks for boolean operations consistency
checkBoolOp :: Type -> Type -> [Char] -> [Char] -> Token -> [Char]
checkBoolOp t1 t2 e1 e2 op  = if (e1 == "") && (e2 == "")
                                then if t2 == t1
                                       then if t1/=TBool
                                              then "Type error at "++(pos op)++": expected boolean type" 
                                              else ""
                                       else "Type error at "++(pos op)++": can't match type "++(showType t1)++" with type "++(showType t2)
                                else if e1/=""
                                       then e1
                                       else e2

-- checks for procedure declaration before a call
checkCallProc :: Id -> [ElemFun] -> [Type] -> Token -> [Char]
checkCallProc id envFun tl p  = if not $ searchFun id envFun
                                  then "Error at "++(pos p)++": procedure  "++(idToStr id)++" not in scope"
                                  else checkParams id envFun tl p  

-- checks for function declaration before a call
checkCallFun :: [Char] -> Id -> [ElemFun] -> [Type] -> Token -> [Char]
checkCallFun e id envFun tl p  = if e==""
                                   then if not $ searchFun id envFun
                                          then "Error at "++(pos p)++": function  "++(idToStr id)++" not in scope"
                                          else checkParams id envFun tl p  
                                   else e

-- checks parameters type correctness when a function/procedure is called
checkParams :: Id -> [ElemFun] -> [Type] -> Token -> [Char]
checkParams id envFun tl p  =  if (length $ getTypeListFun $ extractFun id envFun) /= (length tl)
                                 then "Error at "++(pos p)++": wrong number of arguments when calling "++(idToStr id)++", expected: "++(show $ length $ getTypeListFun $ extractFun id envFun)
                                 else case checkTypesList (getTypeListFun $ extractFun id envFun) tl of {
                                           Just a  -> "Type Error at "++(pos p)++": wrong argument type, couldn't match "++(showType $ fst a)++" with "++(showType $ snd a)++" in function "++(idToStr id);
                                           Nothing -> "";
                                      };

-- check type correctness in assignment
checkTypes :: Type -> [Type] -> Maybe (Type, Type)
checkTypes _ [] = Nothing
checkTypes x (y:ys) | (x == TFloat && y == TInt) || (x == TFloat && y == TBool) || (x == TInt && y == TBool) = checkTypes x ys
                    | x/=y = Just (x,y)
                    | otherwise = checkTypes x ys

-- check type correctness in multiple assignment
checkTypesList :: [Type] -> [Type] -> Maybe (Type, Type)
checkTypesList [] [] = Nothing
checkTypesList (x:xs) (y:ys) | (x == TFloat && y == TInt) || (x == TFloat && y == TBool) || (x == TInt && y == TBool) = checkTypesList xs ys
                             | x/=y = Just (x,y)
                             | otherwise = checkTypesList xs ys

-- check if a parameter variable is already declared in the scope
checkVarParams :: [ElemVar] -> [ElemVar] -> Maybe Id
checkVarParams [] ys = Nothing
checkVarParams (x@(Var a _ _ _):xs) ys
                    | (searchVar a ys) =  Just a
                    | otherwise = (checkVarParams xs ys)

-- check if a variable is alreay declared in a block
checkSameBlock :: Id -> [ElemVar] -> Maybe Id
checkSameBlock id [] = Nothing
checkSameBlock id (Var a _ False _:xs) = checkSameBlock id xs
checkSameBlock id (Var a _ True _:xs)
                      | id==a = Just a
                      | otherwise = checkSameBlock id xs

-- check if any member of a list of variables is already declared in a block
checkSameBlockList :: [Id] -> [ElemVar] -> Maybe Id
checkSameBlockList [] _ = Nothing
checkSameBlockList (x:xs) ys = case checkSameBlock x ys of
                                    Just a  -> Just a
                                    Nothing -> checkSameBlockList xs ys


-- type print functions
showType :: Type -> String
showType TVoid   = "void"
showType TInt    = "int"
showType TFloat  = "float"
showType TChar   = "char"
showType TString = "string"
showType TBool   = "boolean"
showType (TPointer t) = "*" ++ showType t
showType (TArray n t) = showType t ++ "[" ++ (show n) ++ "]"


pos tok = tokenPos [tok]


returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "Syntax error: error at "++tokenPos ts++
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

