-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParGo where
import AbsGo
import LexGo
import ErrM
import Control.Monad
import Structures

}

%attributetype      { MyAttributes a }
%attribute value    { a }
%attribute envV     { [ElmVar] }        
%attribute envF     { [ElmFun] }
%attribute envVMod  { [ElmVar] }
%attribute envFMod  { [ElmFun] }

%attribute idList   { [Id] }
%attribute typ      { Type }
%attribute typList  { [Type] }
%attribute typFun       { Type }
%attribute isReturn     { Bool }
%attribute err       { String }
%attribute loopLabels   { (Int, Int) }
%attribute checkForIncr { Bool }

%attribute tac          { [TacOp] }
%attribute address      { String }
%attribute addressList  { [String] }
%attribute temp         { (Int, Int) }
%attribute tempMod      { (Int, Int) }

%attribute true {Int}
%attribute false {Int}
%attribute tacJ { [TacOp] }


%name pStart Start
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }
%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '%' { PT _ (TS _ 3) }
  '&' { PT _ (TS _ 4) }
  '&&' { PT _ (TS _ 5) }
  '(' { PT _ (TS _ 6) }
  ')' { PT _ (TS _ 7) }
  '*' { PT _ (TS _ 8) }
  '+' { PT _ (TS _ 9) }
  ',' { PT _ (TS _ 10) }
  '-' { PT _ (TS _ 11) }
  '/' { PT _ (TS _ 12) }
  ':=' { PT _ (TS _ 13) }
  '<' { PT _ (TS _ 14) }
  '<=' { PT _ (TS _ 15) }
  '=' { PT _ (TS _ 16) }
  '==' { PT _ (TS _ 17) }
  '>' { PT _ (TS _ 18) }
  '>=' { PT _ (TS _ 19) }
  '[' { PT _ (TS _ 20) }
  ']' { PT _ (TS _ 21) }
  'bool' { PT _ (TS _ 22) }
  'break' { PT _ (TS _ 23) }
  'char' { PT _ (TS _ 24) }
  'continue' { PT _ (TS _ 25) }
  'else' { PT _ (TS _ 26) }
  'false' { PT _ (TS _ 27) }
  'float' { PT _ (TS _ 28) }
  'for' { PT _ (TS _ 29) }
  'func' { PT _ (TS _ 30) }
  'if' { PT _ (TS _ 31) }
  'int' { PT _ (TS _ 32) }
  'package' { PT _ (TS _ 33) }
  'readChar' { PT _ (TS _ 34) }
  'readFloat' { PT _ (TS _ 35) }
  'readInt' { PT _ (TS _ 36) }
  'readString' { PT _ (TS _ 37) }
  'ref' { PT _ (TS _ 38) }
  'return' { PT _ (TS _ 39) }
  'string' { PT _ (TS _ 40) }
  'true' { PT _ (TS _ 41) }
  'val' { PT _ (TS _ 42) }
  'var' { PT _ (TS _ 43) }
  'void' { PT _ (TS _ 44) }
  'writeChar' { PT _ (TS _ 45) }
  'writeFloat' { PT _ (TS _ 46) }
  'writeInt' { PT _ (TS _ 47) }
  'writeString' { PT _ (TS _ 48) }
  '{' { PT _ (TS _ 49) }
  '||' { PT _ (TS _ 50) }
  '}' { PT _ (TS _ 51) }



L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_quoted { PT _ (TL $$) }
L_Id { PT _ (T_Id $$) }

-- precedenze 

%left '&&' '||'
%nonassoc '==' '!=' '<' '<=' '>' '>='  '!'
%left '+' '-' 
%left PUN
%left '*' '/' '%'
%left '='
%left NEG
%right '&'
%left '['


%%

Integer : L_integ  { $$ = (read ( $1)) :: Integer }
Double  : L_doubl  { $$ = (read ( $1)) :: Double }
Char    : L_charac { $$ = (read ( $1)) :: Char }
String  : L_quoted { $$ = $1 }
Id      : L_Id { $$ = Id ($1)}

Boolean : 'true'  { $$ = Boolean_true; } 
        | 'false' { $$ = Boolean_false; }

Type : 'void'      { $$ = TVoid;}
     | 'int'       { $$ = TInt;} 
     | 'bool'      { $$ = TBool;} 
     | 'float'     { $$ = TFloat;} 
     | 'char'      { $$ = TChar;} 
     | 'string'     { $$ = TString;} 
     | '[' Integer ']' Type    { $$ = TArray $2 $4;} 
     | '*' Type    %prec PUN   { $$ = TPointer $2;}

Pass : 'val'                    { $$ = PassVal; } 
     | 'ref'                    { $$ = PassRef; }

RExp : RExp '&&' RExp { 
            $$ = ExpAnd $1 $3; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.err= checkBoolOp $1.typ $3.typ $1.err $3.err $2;  
            $$.typ = TBool;
            $1.temp = $$.temp;
            $3.temp = $1.tempMod;
            $$.tempMod = ( ((fst $3.tempMod) + 1), (snd $3.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            
            $1.true = snd $1.tempMod;
            $1.false = $$.false;
            $3.true = $$.true;
            $3.false = $$.false;
            
            $$.tac = $1.tac ++ $3.tac ++ [(BinOp "&&" $$.address $1.address $3.address)];
            $$.tacJ = $1.tacJ ++ [(CondJ $1.address ($1.true+2))] ++ $3.tacJ ++ [(BinOp "&&" $$.address $1.address $3.address)];
            where (case checkBoolOp $1.typ $3.typ $1.err $3.err $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                });
            }

     | RExp '||' RExp { 
            $$ = ExpOr $1 $3; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.err= checkBoolOp $1.typ $3.typ $1.err $3.err $2;  
            $$.typ = TBool;
            $1.temp = $$.temp;
            $3.temp = $1.tempMod;
            $$.tempMod = ( ((fst $3.tempMod) + 1), (snd $3.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            
            $1.true = snd $1.tempMod;
            $1.false = $$.false;
            $3.true = $$.true;
            $3.false = $$.false;
            
            $$.tac = $1.tac ++ $3.tac ++ [(BinOp "||" $$.address $1.address $3.address)];
            $$.tacJ = $1.tacJ ++ [(CondJTrue $1.address ($1.true+1))] ++ $3.tacJ ++ [(BinOp "||" $$.address $1.address $3.address)];
            where (case checkBoolOp $1.typ $3.typ $1.err $3.err $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                });
            }

     | '!' RExp { 
            $$ = ExpNot $2; 
            $2.envV = $$.envV;
            $2.envF = $$.envF;
            $$.err = if ($2.err == "")  
                    then    (if (not($2.typ == TBool))
                        then "Type Error at "++(pos $1)++": Expected boolean type"
                        else ""
                    )
                    else $2.err;
            $$.typ = TBool;
            $2.temp = $$.temp;
            $$.tempMod = ( ((fst $2.tempMod) + 1), (snd $2.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            $$.tac = $2.tac ++ [(UnOp "!" $$.address $2.address)];
            where ( if ($2.err == "")  
                then    (if (not($2.typ == TBool))
                    then Bad $ "Type Error at "++(pos $1)++": Expected boolean type"
                    else Ok ()
                    )
                else Bad $ $2.err );
            }

     | RExp '==' RExp { 
            $$ = ExpEq $1 $3; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;      
            $$.err= checkRelOp $1.typ $3.typ $1.err $3.err $2;   
            $$.typ = TBool;
            $1.temp = $$.temp;
            $3.temp = $1.tempMod;
            $$.tempMod = ( ((fst $3.tempMod) + 1), (snd $3.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            $$.tac = $1.tac ++ $3.tac ++ [(BinOp "==" $$.address $1.address $3.address)]; 
            where (case checkRelOp $1.typ $3.typ $1.err $3.err $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                });
            }

     | RExp '!=' RExp { 
            $$ = ExpNeq $1 $3; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.err= checkRelOp $1.typ $3.typ $1.err $3.err $2;   
            $$.typ = TBool;
            $1.temp = $$.temp;
            $3.temp = $1.tempMod;
            $$.tempMod = ( ((fst $3.tempMod) + 1), (snd $3.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            $$.tac = $1.tac ++ $3.tac ++ [(BinOp "!=" $$.address $1.address $3.address)];
            where (case checkRelOp $1.typ $3.typ $1.err $3.err $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                });
            }

     | RExp '<' RExp { 
            $$ = ExpLt $1 $3; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.err= checkRelOp $1.typ $3.typ $1.err $3.err $2;   
            $$.typ = TBool;
            $1.temp = $$.temp;
            $3.temp = $1.tempMod;
            $$.tempMod = ( ((fst $3.tempMod) + 1), (snd $3.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            $$.tac = $1.tac ++ $3.tac ++ [(BinOp "<" $$.address $1.address $3.address)];
            where (case checkRelOp $1.typ $3.typ $1.err $3.err $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                });
            }

     | RExp '<=' RExp { 
            $$ = ExpLtE $1 $3; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.err= checkRelOp $1.typ $3.typ $1.err $3.err $2;   
            $$.typ = TBool;
            $1.temp = $$.temp;
            $3.temp = $1.tempMod;
            $$.tempMod = ( ((fst $3.tempMod) + 1), (snd $3.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            $$.tac = $1.tac ++ $3.tac ++ [(BinOp "<=" $$.address $1.address $3.address)];
            where (case checkRelOp $1.typ $3.typ $1.err $3.err $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                });
            }

     | RExp '>' RExp { 
            $$ = ExpGt $1 $3; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.err= checkRelOp $1.typ $3.typ $1.err $3.err $2;   
            $$.typ = TBool;
            $1.temp = $$.temp;
            $3.temp = $1.tempMod;
            $$.tempMod = ( ((fst $3.tempMod) + 1), (snd $3.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            $$.tac = $1.tac ++ $3.tac ++ [(BinOp ">" $$.address $1.address $3.address)];
            where (case checkRelOp $1.typ $3.typ $1.err $3.err $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                });
            }

     | RExp '>=' RExp { 
            $$ = ExpGtE $1 $3; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.err= checkRelOp $1.typ $3.typ $1.err $3.err $2;   
            $$.typ = TBool;
            $1.temp = $$.temp;
            $3.temp = $1.tempMod;
            $$.tempMod = ( ((fst $3.tempMod) + 1), (snd $3.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            $$.tac = $1.tac ++ $3.tac ++ [(BinOp ">=" $$.address $1.address $3.address)];
            where (case checkRelOp $1.typ $3.typ $1.err $3.err $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                });
            }

     | RExp '+' RExp { 
            $$ = ExpAdd $1 $3; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.err= (checkMathOp $1.typ $3.typ $1.err $3.err $2);    
            $$.typ = if (($1.typ == TInt) && ($3.typ == TInt)) then TInt else TFloat ;
            $1.temp = $$.temp;
            $3.temp = $1.tempMod;
            $$.tempMod = ( ((fst $3.tempMod) + 1), (snd $3.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            $$.tac = $1.tac ++ $3.tac ++ [(BinOp "+" $$.address $1.address $3.address)]; 
            where (case checkMathOp $1.typ $3.typ $1.err $3.err $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                });
            } 

     | RExp '-' RExp { 
            $$ = ExpSub $1 $3;
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.err= (checkMathOp $1.typ $3.typ $1.err $3.err $2);    
            $$.typ = if (($1.typ == TInt) && ($3.typ == TInt)) then TInt else TFloat ;
            $1.temp = $$.temp;
            $3.temp = $1.tempMod;
            $$.tempMod = ( ((fst $3.tempMod) + 1), (snd $3.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            $$.tac = $1.tac ++ $3.tac ++ [(BinOp "-" $$.address $1.address $3.address)]; 
            where (case checkMathOp $1.typ $3.typ $1.err $3.err $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                });
            }

     | RExp '*' RExp { 
            $$ = ExpMul $1 $3; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.err= (checkMathOp $1.typ $3.typ $1.err $3.err $2);    
            $$.typ = if (($1.typ == TInt) && ($3.typ == TInt)) then TInt else TFloat ;
            $1.temp = $$.temp;
            $3.temp = $1.tempMod;
            $$.tempMod = ( ((fst $3.tempMod) + 1), (snd $3.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            $$.tac = $1.tac ++ $3.tac ++ [(BinOp "*" $$.address $1.address $3.address)]; 
            where (case checkMathOp $1.typ $3.typ $1.err $3.err $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                });
            }

     | RExp '/' RExp { 
            $$ = ExpDiv $1 $3; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.err= (checkMathOp $1.typ $3.typ $1.err $3.err $2);    
            $$.typ = if (($1.typ == TInt) && ($3.typ == TInt)) then TInt else TFloat ;
            $1.temp = $$.temp;
            $3.temp = $1.tempMod;
            $$.tempMod = ( ((fst $3.tempMod) + 1), (snd $3.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            $$.tac = $1.tac ++ $3.tac ++ [(BinOp "/" $$.address $1.address $3.address)]; 
            where (case checkMathOp $1.typ $3.typ $1.err $3.err $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                });
            }

     | RExp '%' RExp { 
            $$ = ExpMod $1 $3; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.err= (checkMathOp $1.typ $3.typ $1.err $3.err $2);    
            $$.typ = if (($1.typ == TInt) && ($3.typ == TInt)) then TInt else TFloat ;
            $1.temp = $$.temp;
            $3.temp = $1.tempMod;
            $$.tempMod = ( ((fst $3.tempMod) + 1), (snd $3.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            $$.tac = $1.tac ++ $3.tac ++ [(BinOp "%" $$.address $1.address $3.address)]; 
            where (case checkMathOp $1.typ $3.typ $1.err $3.err $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                });
            }

     | '-' RExp  %prec NEG { 
            $$ = ExpNeg $2; 
            $2.envV = $$.envV;
            $2.envF = $$.envF;
            $$.err = if ($2.err == "")  
                    then    (if (not($2.typ == TInt || $2.typ == TFloat))
                        then "Type Error at "++(pos $1)++": Expected numeric type (int or float)"
                        else ""
                    )
                    else $2.err;
            $$.typ = $2.typ;
            $2.temp = $$.temp;
            $$.tempMod = ( ((fst $2.tempMod) + 1), (snd $2.tempMod) );
            $$.address = "t"++ (show  (fst $$.tempMod) );
            $$.tac = $2.tac ++ [(UnOp "-" $$.address $2.address)];
            where ( if ($2.err == "")  
                then    (if (not($2.typ == TInt || $2.typ == TFloat))
                    then Bad $ "Type Error at "++(pos $1)++": Expected numeric type (int or float)"
                    else Ok ()
                    )
                else Bad $ $2.err );
            }

     | '&' LExp { 
            $$ = ExpRef $2;
            $2.envV = $$.envV;
            $2.envF = $$.envF;
            $$.err = $2.err;
            $$.typ = TPointer $2.typ;
            $2.temp = $$.temp;
            $$.tempMod = ( ((fst $2.tempMod) + 1), (snd $2.tempMod) );
            $$.address = "t"++(show (fst $$.tempMod) );
            $$.tac = $2.tac ++ [(NulOp $$.address ("&"++$2.address))];
            }

     | Id '(' ')' { 
            $$ = ExpFuncEmpty $1; 
            $$.typ = getTypeFun (extrFun $1 $$.envF);   
            $$.err = checkErrProc $1 $$.envF [] $2;
            $$.tempMod = if ($$.typ==TVoid) then ( $$.temp ) else ( ((fst $$.temp) + 1), (snd $$.temp) );
            $1.address = (idToStr $1) ++ getPosF $1 $$.envF;
            $$.address = if ($$.typ==TVoid) then ("") else ("t"++(show (fst $$.tempMod)));
            $$.tac = if ($$.typ==TVoid) then [FunCall "procedure" "" (Id $1.address) []] else [FunCall "function" $$.address(Id $1.address) []];
            where (case checkErrProc $1 $$.envF [] $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                }); 
            }

     | Id '(' ListRExp ')' { 
            $$ = ExpFunc $1 $3; 
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.typ = getTypeFun (extrFun $1 $$.envF);
            $$.err = checkErrFun $3.err $1 $$.envF $3.typList $2;
            $3.temp = $$.temp;
            $$.tempMod = if ($$.typ==TVoid) then ( $3.tempMod ) else ( ((fst $3.tempMod) + 1), (snd $3.tempMod) );
            $1.address = (idToStr $1) ++ getPosF $1 $$.envF;
            $$.address = if ($$.typ==TVoid) then ("") else ("t"++(show (fst $$.tempMod) )); 
            $$.tac = if ($$.typ==TVoid) 
                    then $3.tac ++ [FunCall "procedure" "" (Id $1.address) $3.addressList] 
                    else $3.tac ++ [FunCall "function" $$.address (Id $1.address) $3.addressList];
            where (case checkErrFun $3.err $1 $$.envF $3.typList $2 of {
                    "" -> Ok ();
                    x -> Bad $ x;               
                });

            }

     | Val { 
            $$ = ExpVal $1; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $$.typ = $1.typ;
            $$.err = "";
            $$.tempMod = $$.temp;
            $$.address = (showVal $1);
            $$.tac = [];
            $$.tacJ = [];
            }

     | LExp { 
            $$ = ExpLExp $1;
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $$.typ = $1.typ;
            $$.err = $1.err;
            $1.temp = $$.temp;
            $$.tempMod = $1.tempMod;
            $$.address = $1.address;
            $$.tac = $1.tac;
            $$.tacJ = $$.tac;
            }

     | '(' RExp ')' { 
            $$ = ExpPar $2; 
            $2.envV = $$.envV;
            $2.envF = $$.envF;
            $$.typ = $2.typ;
            $$.err = $2.err;
            $2.temp = $$.temp;
            $$.tempMod = $2.tempMod;
            $$.address = $2.address;
            $$.tac = $2.tac;
            }

     | 'readInt' '(' ')' { 
                $$ = StRead ReadT_readInt;
                $$.typ = TInt;
                $$.isReturn = False;
                $$.tempMod = $$.temp;
                $$.address = "t"++(show ((fst $$.tempMod) + 1) );
                $$.tac = [FunCall "function" $$.address (Id "readInt") []];
                }

     | 'readFloat' '(' ')' { 
                $$ = StRead ReadT_readFloat;
                $$.typ = TFloat;
                $$.isReturn = False;
                $$.tempMod = $$.temp;
                $$.address = "t"++(show ((fst $$.tempMod) + 1) );
                $$.tac = [FunCall "function" $$.address (Id "readFloat") []];
                }

     | 'readChar' '(' ')' { 
                $$ = StRead ReadT_readChar;
                $$.typ = TChar;
                $$.isReturn = False;
                $$.tempMod = $$.temp;
                $$.address = "t"++(show ((fst $$.tempMod) + 1) );
                $$.tac = [FunCall "function" $$.address (Id "readChar") []];
                }

     | 'readString' '(' ')' { 
                $$ = StRead ReadT_readString;
                $$.typ = TString;
                $$.isReturn = False;
                $$.tempMod = $$.temp;
                $$.address = "t"++(show ((fst $$.tempMod) + 1) );
                $$.tac = [FunCall "function" $$.address (Id "readString") []];
                }

Val : Integer { 
        $$ = Int $1; 
        $$.typ = TInt;
        } 

    | Double { 
        $$ = Float $1; 
        $$.typ = TFloat;
        }

    | Char { 
        $$ = Char $1; 
        $$.typ = TChar;
        }

    | String { 
        $$ = String $1; 
        $$.typ = TString;
        }

    | Boolean { 
        $$ = Bool $1; 
        $$.typ = TBool;
        }

LExp : Id { 
            $$ = ExpId $1; 
            $$.typ = getTypeVar (extrVar $1 $$.envV);
            $$.err = if (not(searchVar $1 $$.envV)) 
                    then  "Scope Error : Variable  "++(idToStr $1)++" not in scope"
                    else "";
            $$.tempMod = $$.temp;
            $$.address = (idToStr $1) ++ (getPosV $1 $$.envV);
            $$.tac = [];
            where ( if (not(searchVar $1 $$.envV)) 
                then ( Bad $ "Scope Error : Variable  "++(idToStr $1)++" not in scope")
                else ( Ok ()) 
                );
        
            } 

     | LExp '[' RExp ']' { 
            $$ = ExpArr $1 $3; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.typ = getTypeArr $1.typ;
            $$.err = if ( ($1.err == "") && ($3.err == "")  )
                    then  (case $1.typ of { 
                        (TArray _ _ ) -> (if (not($3.typ == TInt)) 
                                     then "Type Error at "++(pos $2)++": Type int expected, founded " ++ showType ($3.typ) 
                                     else ""
                                    );
                        otherwise    ->  "Type Error at "++(pos $2)++": Type array expected, founded " ++ showType ($1.typ) ;
                        })
                     else (if $1.err==""
                            then $3.err
                        else $1.err); 
            $1.temp = $$.temp;
            $3.temp = $$.temp;
            $$.tempMod = ( ((fst $3.tempMod) + 2), (snd $3.tempMod) );
            $$.address = $1.address++"[t"++(show ((fst $3.tempMod) +1))++"]";
            $$.tac = $1.tac ++ $3.tac ++ [ BinOp "*" ("t"++(show ((fst $3.tempMod) +1))) $3.address ( show (mem $$.typ) ) ];




            where (  if ( ($1.err == "") && ($3.err == "")  )
                    then  case $1.typ of { 
                        (TArray _ _ ) -> (if (not($3.typ == TInt)) 
                                     then Bad $ "Type Error at "++(pos $2)++": Type int expected, founded " ++ showType ($3.typ) 
                                     else Ok ()
                                    );
                        otherwise    -> ( Bad $ "Type Error at "++(pos $2)++": Type array expected, founded " ++ showType ($1.typ) );
                    }
                     else (if $1.err==""
                            then Bad $ $3.err
                        else Bad $ $1.err)); 
            }

     | '*' RExp %prec PUN { 
            $$ = ExpDeref $2; 
            $2.envV = $$.envV;
            $2.envF = $$.envF;
            $$.typ = getTypePnt $2.typ;
            $$.err = ( if  $2.err==""
                    then if  (not(isTyipePnt $2.typ)) 
                        then "Type Error at "++(pos $1)++": Type pointer expected, founded " ++ showType ($2.typ)
                        else ""
                    else $2.err);
            $2.temp = $$.temp;
            $$.tempMod = ( ((fst $2.tempMod) + 1), (snd $2.tempMod) );
            $$.address = "*"++($2.address);
            $$.tac = $2.tac;
            where ( if $2.err==""
                    then if  not(isTyipePnt $2.typ) 
                        then  Bad $ "Type Error at "++(pos $1)++": Type pointer expected, founded " ++ showType ($2.typ)
                        else Ok ()
                    else Bad $ $2.err );
            }

Start : 'package' Id ListDecl {
                    $$ = (Entry $2 (reverse $3), $$.tac);
                    $$.typ = TInt; 
                    $$.envV = [];
                    $$.envF = [];
                    $3.envV = $$.envV;
                    $3.envF = $$.envF;
                    $3.temp = (0,0);
                    $$.tac = $3.tac;
                    } 

Decl : 'var' ListId Type  { 
                        $$ = DeclVar $2 $3;
                        $$.idList = setPos $2 (pos $1);
                        $$.envVMod = (unionVar (createList $2 $3 (pos $1)) $$.envV);
                        $$.envFMod = $$.envF;
                        $$.tempMod = $$.temp;
                        $$.tac = [] ;
                        where ( case (ctrlDeclVarList $$.idList $$.envV) of {
                                Just a -> Bad $ "Scope Error at "++(pos $1)++": variable "++(idToStr a)++" already declared in this block" ;
                                Nothing -> Ok ();
                            });
                        }

     | 'var' ListId '=' ListRExp { 
                        $$ = DeclVarInit $2 $4;
                        $$.idList = setPos $2 (pos $1);
                        $4.envV = $$.envV;
                        $4.envF = $$.envF;                              
                        $$.envVMod = (unionVar ( createListMod $2 $4.typList (pos $1)) $$.envV);
                        $$.envFMod = $$.envF;
                        $4.temp = $$.temp;
                        $$.tempMod = $4.tempMod;
                        $$.tac = $4.tac ++ ( tacAssign $$.idList $4.addressList );
                        where ( case (ctrlDeclVarList $2 $$.envV) of {
                                Just a -> Bad $ "Scope Error at "++(pos $1)++": variable "++(idToStr a)++" already declared in this block";
                                Nothing -> ( if (not(length $2 == length $4.typList)) 
                                        then Bad $ "Sintax Error at "++(pos $1)++": n.of id and expression not matching"
                                        else Ok ()  );
                                }
                            );
                        }
                        
     | 'var' ListId Type '=' ListRExp { 
                        $$ = DeclVarTypeInit $2 $3 $5;
                        $$.idList = setPos $2 (pos $1);
                        $5.envV = $$.envV;
                        $5.envF = $$.envF;                              
                        $$.envVMod = (unionVar ( createList $2 $3 (pos $1)) $$.envV);
                        $$.envFMod = $$.envF;
                        $5.temp = $$.temp;
                        $$.tempMod = $5.tempMod;
                        $$.tac = $5.tac ++ ( tacAssign $$.idList $5.addressList );
                        where ( case (ctrlDeclVarList $2 $$.envV) of {
                                Just a -> Bad $ "Scope Error at "++(pos $1)++": variable "++(idToStr a)++" already declared in this block";
                                Nothing -> ( if (not(length $2 == length $5.typList)) 
                                               then Bad $ "Sintax Error at "++(pos $1)++": n.of id and expression not matching"
                                               else ( case ( matchType $3 ($5.typList)) of {
						                          Just a  -> Bad $ "Type Error at: "++(pos $4)++" Cannot use "++(showType (fst a))++" as type "++(showType (snd a))++" in assignment";
						                          Nothing -> Ok () ;
                                          }
                                       )
                                    );
                                }
                            );
                        }

     | 'func' Id '(' ListParam ')' Type Block { 
                        $$ = DeclFun $2 $4 $6 $7;
                        $$.idList = setPos [$2] (pos $1);
                        $$.envVMod = $$.envV;
                        $$.envFMod = ( insFun (Fun $2 $6 $4.typList (pos $1)) $$.envF );
                        $7.envV = (unionVar $4.envV (resetEnvV $$.envV) );
                        $7.envF = $$.envFMod;
                        $7.typFun = $6;
                        $7.loopLabels = (-1,-1);
                        $7.temp = $$.temp;
                        $$.tempMod = ( (fst $7.tempMod) , ((snd $7.tempMod)+1) );
                        $$.tac = [FunDecl "function" (Id $ idToStr $ head $$.idList) (length $4.typList)]++$7.tac++[Lbl ((snd $7.tempMod)+1)] ;
                        where (if (searchFun $2 $$.envF) 
                            then Bad $ "Scope Error at "++(pos $1)++": function "++(idToStr $2)++" already declared"
                            else when (not($7.isReturn)) $ Bad $ "Sintax Error at "++(pos $1)++": missing return at end of function" );
                        }

     | 'func' Id '(' ListParam ')' 'void' Block { 
                        $$ = DeclProc $2 $4 $7;
                        $$.idList = setPos [$2] (pos $1);
                        $$.envVMod = $$.envV;
                        $$.envFMod = (insFun (Fun $2 TVoid $4.typList (pos $1)) $$.envF);
                        $7.envV = (unionVar $4.envV (resetEnvV $$.envV) ); 
                        $7.envF = $$.envFMod;
                        $7.typFun = TVoid; 
                        $7.loopLabels = (-1,-1);
                        $7.temp = $$.temp;
                        $$.tempMod = ( (fst $7.tempMod) , ((snd $7.tempMod)+1) );
                        $$.tac = [FunDecl "procedure" (Id $ idToStr $ head $$.idList) (length $4.typList)]++$7.tac++[Lbl ((snd $7.tempMod)+1)] ;
                        where (if (searchFun $2 $$.envF) 
                            then Bad $ "Scope Error at "++(pos $1)++": procedure "++(idToStr $2)++" already declared"
                            else Ok () );
                        }

ShortVarDecl : ListId ':=' ListRExp {
                        $$ = DeclVarShort $1 $3;
                        $$.idList = setPos $1 (pos $2);
                        $3.envV = $$.envV;
                        $3.envF = $$.envF;
                        $$.envVMod = (unionVar ( createListMod $1 $3.typList (pos $2)) $$.envV);
                        $$.envFMod = $$.envF;
                        $3.temp = $$.temp;
                        $$.tempMod = $3.tempMod;
                        $$.tac = $3.tac ++ ( tacAssign $$.idList $3.addressList );
                        where ( case (ctrlDeclVarList $1 $$.envV) of {
                                Just a -> Bad $ "Scope Error at "++(pos $2)++": variable "++(idToStr a)++" already declared in this block";
                                Nothing -> ( if (not(length $1 == length $3.typList)) 
                                        then Bad $ "Sintax Error at "++(pos $2)++": n.of id and expression not matching"
                                        else Ok ()  );
                                }
                            );
                        }

Param : ListId Type { 
                  $$ = Parameter $1 $2; 
                  $$.envV = (createList $1 $2 "0");
                  $$.typList = (replicate (length $1) $2);
                  } 

      | Pass ListId Type { 
                  $$ = ParameterPass $1 $2 $3; 
                  $$.envV = (createList $2 $3 "0");
                  $$.typList = (replicate (length $2) $3);
                  }

Block : '{' ListStmt '}' { 
                    $$ = (BodyBlock (reverse $2)); 
                    $2.envV = $$.envV;
                    $2.envF = $$.envF;
                    $$.envVMod = $$.envV;
                    $$.envFMod = $$.envF;
                    $2.typFun = $$.typFun;
                    $$.isReturn = $2.isReturn;
                    $2.loopLabels = $$.loopLabels;
                    $2.temp = $$.temp;
                    $$.tempMod = $2.tempMod;
                    $$.tac = $2.tac;
                    }

Stmt : Decl { 
              $$ = StDecl $1; 
              $1.envV = $$.envV;
              $1.envF = $$.envF;
              $$.envVMod = $1.envVMod;
              $$.envFMod = $1.envFMod;
              $$.isReturn = False;
              $1.temp = $$.temp;
              $$.tempMod = $1.tempMod;                    
              $$.tac = $1.tac;
              }

     | Block { 
              $$ = StBlock $1; 
              $1.envV = (resetEnvV $$.envV);
              $1.envF = $$.envF;
              $$.envVMod = $$.envV;
              $$.envFMod = $$.envF;
              $1.typFun = $$.typFun;
              $$.isReturn = False;
              $1.loopLabels = $$.loopLabels;
              $1.temp = $$.temp;
              $$.tempMod = $1.tempMod;
              $$.tac = $1.tac;
              }

     | StmtSmpl { 
              $$ = StSmpl $1; 
              $1.envV = $$.envV;
              $1.envF = $$.envF;
              $$.envVMod = $1.envVMod;
              $$.envFMod = $1.envFMod;
              $$.isReturn = False;
              $1.temp = $$.temp;
              $$.tempMod = $1.tempMod;
              $$.tac = $1.tac;
              }

     | 'if' RExp Block { 
                    $$ = StIf $2 $3; 
                    $2.envV = $$.envV;
                    $2.envF = $$.envF;
                    $3.envV = (resetEnvV $$.envV);
                    $3.envF = $$.envF;
                    $$.envVMod = $$.envV;
                    $$.envFMod = $$.envF;
                    $3.typFun = $$.typFun;
                    $$.isReturn = False;
                    $3.loopLabels = $$.loopLabels;
                    $2.temp = $$.temp;
                    $3.temp = $2.tempMod;
                    $$.tempMod = ( (fst $3.tempMod) , ((snd $3.tempMod)+2) );
                    $$.tac = $2.tac ++ [CondJ $2.address ((snd $3.tempMod)+2)]
                            ++ [Lbl ((snd $3.tempMod)+1)]
                            ++ $3.tac
                            ++ [Lbl ((snd $3.tempMod)+2)];
                    where ( if ($2.err== "") 
                        then (when (not($2.typ == TBool)) $ Bad $ "Type Error at "++(pos $1)++": Type "++ (showType $2.typ) ++" used as if-condition" )
                        else ( Bad $ $2.err) 
                    );
                    }

     | 'if' RExp Block 'else' Block { 
                    $$ = StIfElse $2 $3 $5;
                    $2.envV = $$.envV;
                    $2.envF = $$.envF;
                    $3.envV = (resetEnvV $$.envV);
                    $3.envF = $$.envF;
                    $5.envV = (resetEnvV $$.envV);
                    $5.envF = $$.envF;
                    $$.envVMod = $$.envV;
                    $$.envFMod = $$.envF;
                    $3.typFun = $$.typFun;
                    $5.typFun = $$.typFun;
                    $$.isReturn = False;
                    $3.loopLabels = $$.loopLabels;
                    $5.loopLabels = $$.loopLabels;
                    $2.temp = $$.temp;
                    $3.temp = $2.tempMod;
                    $5.temp = $3.tempMod;
                    $$.tempMod = ( (fst $5.tempMod) , ((snd $5.tempMod)+3) );
                    $$.tac = shift $2.tacJ (snd $5.tempMod)
                          ++ [CondJ $2.address ((snd $5.tempMod)+2)]
                          ++ [Lbl ((snd $5.tempMod)+1)]
                          ++ $3.tac
                          ++ [UnCondJ ((snd $5.tempMod)+3)]
                          ++ [Lbl ((snd $5.tempMod)+2)]
                          ++ $5.tac
                          ++ [Lbl ((snd $5.tempMod)+3)];
                    where ( if ($2.err== "") 
                        then (when (not($2.typ == TBool)) $ Bad $ "Type Error at "++(pos $1)++": Type "++ (showType $2.typ) ++" used as if-condition" )
                        else ( Bad $ $2.err) 
                    );
                    }

     | 'for' RExp Block { 
                $$ = StWhile $2 $3;
                $2.envV = $$.envV;
                $2.envF = $$.envF;
                $3.envV = (resetEnvV $$.envV);
                $3.envF = $$.envF;
                $$.envVMod = $$.envV;
                $$.envFMod = $$.envF;
                $3.typFun = $$.typFun;
                $$.isReturn = False;
                $3.loopLabels = ( ((snd $3.tempMod)+1) , ((snd $3.tempMod)+2) );
                $2.temp = $$.temp;
                $3.temp = $2.tempMod;                   
                $$.tempMod = ( (fst $3.tempMod) , ((snd $3.tempMod)+2) );
                $$.tac = [Lbl ((snd $3.tempMod)+1)]
                        ++ $2.tac
                        ++ [CondJ $2.address ((snd $3.tempMod)+2)]
                        ++ $3.tac
                        ++ [UnCondJ ((snd $3.tempMod)+1)]
                        ++ [Lbl ((snd $3.tempMod)+2)];
                where ( if ($2.err== "")
                    then (when (not($2.typ == TBool)) $ Bad $ "Type Error at "++(pos $1)++": Type "++ (showType $2.typ) ++" used as for-condition" )
                    else ( Bad $ $2.err)
                );
                }

     | 'break' { 
                $$ = StBreak; 
                $$.envVMod = $$.envV;
                $$.envFMod = $$.envF;
                $$.isReturn = False;
                $$.tempMod = $$.temp;
                $$.tac = [UnCondJ (snd $$.loopLabels)];                 
                where (when ( (fst $$.loopLabels) == (-1) ) $ Bad $ "Sintax Error at "++(pos $1)++": Break is not in a loop" );
                }

     | 'continue' { 
                $$ = StContinue;
                $$.envVMod = $$.envV;
                $$.envFMod = $$.envF;
                $$.isReturn = False;
                $$.tempMod = $$.temp;
                $$.tac = [UnCondJ (fst $$.loopLabels)];             
                where (when ( (fst $$.loopLabels) == (-1) ) $ Bad $ "Sintax Error at "++(pos $1)++": Continue is not in a loop" );
                }

     | 'return' RExp { 
                    $$ = StReturn $2; 
                    $2.envV = $$.envV;
                    $2.envF = $$.envF;
                    $$.envVMod = $$.envV;
                    $$.envFMod = $$.envF;
                    $$.isReturn = True;
                    $2.temp = $$.temp;
                    $$.tempMod = $2.tempMod;
                    $$.tac = $2.tac ++ [ Return $2.address ];
                    where ( if ($2.err== "") 
                        then ( case $$.typFun of {
                            TVoid -> ( Bad $ "Sintax Error at "++(pos $1)++": Cannot return any value" );
                            _ -> ( when (not($2.typ == $$.typFun)) $ Bad $ "Type Error at "++(pos $1)++": Cannot use type "++(showType $2.typ)++" as type "++(showType $$.typFun)++" in return argument" );

                        })
                        else ( Bad $ $2.err) 
                    );
                    }

     | 'writeInt' '(' RExp ')' { 
                    $$ = StWrite WriteT_writeInt $3;
                    $3.envV = $$.envV;
                    $3.envF = $$.envF;
                    $$.envVMod = $$.envV;
                    $$.envFMod = $$.envF;
                    $$.isReturn = False;
                    $3.temp = $$.temp;
                    $$.tempMod = $3.tempMod;
                    $$.tac = $3.tac ++ [FunCall "procedure" "" (Id "writeInt") [$3.address]];
                    where ( if $3.err == ""
                        then when ( not $ $3.typ == TInt ) $ Bad $ "Type Error at "++(pos $2)++": needed integer input when using writeInt"
                        else Bad $ $3.err );
                    }

     | 'writeFloat' '(' RExp ')' { 
                    $$ = StWrite WriteT_writeFloat $3;
                    $3.envV = $$.envV;
                    $3.envF = $$.envF;
                    $$.envVMod = $$.envV;
                    $$.envFMod = $$.envF;
                    $$.isReturn = False;
                    $3.temp = $$.temp;
                    $$.tempMod = $3.tempMod;
                    $$.tac = $3.tac ++ [FunCall "procedure" "" (Id "writeFloat") [$3.address]];
                    where ( if $3.err == ""
                        then when ( not $ $3.typ == TFloat ) $ Bad $ "Type Error at "++(pos $2)++": needed float input when using writeFloat"
                        else Bad $ $3.err );
                    }

     | 'writeChar' '(' RExp ')' { 
                    $$ = StWrite WriteT_writeChar $3;
                    $3.envV = $$.envV;
                    $3.envF = $$.envF;
                    $$.envVMod = $$.envV;
                    $$.envFMod = $$.envF;
                    $$.isReturn = False;
                    $3.temp = $$.temp;
                    $$.tempMod = $3.tempMod;
                    $$.tac = $3.tac ++ [FunCall "procedure" "" (Id "writeChar") [$3.address]];
                    where ( if $3.err == ""
                        then when ( not $ $3.typ == TChar ) $ Bad $ "Type Error at "++(pos $2)++": needed char input when using writeChar"
                        else Bad $ $3.err );
                    }

     | 'writeString' '(' RExp ')' { 
                    $$ = StWrite WriteT_writeString $3;
                    $3.envV = $$.envV;
                    $3.envF = $$.envF;
                    $$.envVMod = $$.envV;
                    $$.envFMod = $$.envF;
                    $$.isReturn = False;
                    $3.temp = $$.temp;
                    $$.tempMod = $3.tempMod;
                    $$.tac = $3.tac ++ [FunCall "procedure" "" (Id "writeString") [$3.address]];
                    where ( if $3.err == ""
                        then when ( not $ $3.typ == TString ) $ Bad $ "Type Error at "++(pos $2)++": needed string input when using writeString"
                        else Bad $ $3.err );
                    }

StmtSmpl : ShortVarDecl { 
                $$ = StShortVarDecl $1; 
                $1.envV = $$.envV;
                $1.envF = $$.envF;
                $$.envVMod = $1.envVMod;
                $$.envFMod = $1.envFMod;
                $$.checkForIncr = False;
                $1.temp = $$.temp;
                $$.tempMod = $1.tempMod;
                $$.tac = $1.tac ;
                } 

         | RExp { 
                $$ = StExp $1; 
                $1.envV = $$.envV;
                $1.envF = $$.envF;
                $$.envVMod = $$.envV;
                $$.envFMod = $$.envF;
                $$.checkForIncr = True;
                $1.temp = $$.temp;
                $$.tempMod = $1.tempMod;
                $$.tac = $1.tac;
                where ( if ($1.err== "") 
                    then ( if ($1.address == "")
                        then Ok ()
                        else Bad $ "Sintax Error : Right expression not assigned")
                    else ( Bad $ $1.err) 
                );
                }

         | LExp '=' RExp { 
                $$ = StAsgn $1 $3; 
                $1.envV = $$.envV;
                $1.envF = $$.envF;
                $3.envV = $$.envV;
                $3.envF = $$.envF;
                $$.envVMod = $$.envV;
                $$.envFMod = $$.envF;
                $$.checkForIncr = True;
                $1.temp = $$.temp;
                $3.temp = $1.tempMod;
                $$.tempMod = $3.tempMod;
                $$.tac = $1.tac ++ $3.tac ++ [NulOp $1.address $3.address] ;
                where ( if ( ($1.err== "") && ($3.err== "" ) ) 
                        then (if (($1.typ == TFloat) && ($3.typ == TInt)) 
                            then (Ok ()) 
                            else when (not($1.typ == $3.typ)) $ Bad $ "Type Error at "++(pos $2)++": Cannot use "++(showType $3.typ)++" as type "++(showType $1.typ)++" in assignment"
                        )
                        else (if not($1.err=="")
                                then Bad $ $1.err
                            else Bad $ $3.err
                            )
                    ); 
                }


ListRExp : RExp { 
            $$ = (:[]) $1; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $$.typList = [$1.typ];
            $$.err = $1.err;
            $1.temp = $$.temp;
            $$.tempMod = $1.tempMod;
            $$.addressList = [$1.address];
            $$.tac = $1.tac;
            } 

         | RExp ',' ListRExp { 
            $$ = (:) $1 $3; 
            $1.envV = $$.envV;
            $1.envF = $$.envF;
            $3.envV = $$.envV;
            $3.envF = $$.envF;
            $$.typList = ( $1.typ : $3.typList );
            $$.err = $1.err;
            $1.temp = $$.temp;
            $3.temp = $1.tempMod;
            $$.tempMod = $3.tempMod;
            $$.addressList = $1.address : $3.addressList;
            $$.tac = $1.tac ++ $3.tac;
            }

ListDecl : {- empty -} { 
                $$ = []; 
                $$.envVMod = $$.envV;
                $$.envFMod = $$.envF;
                $$.tempMod = $$.temp;
                $$.tac = [];
                } 

         | ListDecl Decl { 
                $$ = flip (:) $1 $2; 
                $1.envV = $$.envV;
                $1.envF = $$.envF;
                $2.envV = $1.envVMod;
                $2.envF = $1.envFMod;
                $$.envVMod = $2.envVMod;
                $$.envFMod = $2.envFMod;
                $1.temp = $$.temp;
                $2.temp = $1.tempMod;
                $$.tempMod = $2.tempMod;
                $$.tac = $1.tac ++ $2.tac;
                }

ListId : Id { 
            $$ = (:[]) $1;
            $$.idList = [$1];
            } 

       | Id ',' ListId { 
            $$ = (:) $1 $3;
            $$.idList = ( $1 : $3.idList ) ;
            where ( when (elem $1 $3) $ Bad $ "Sintax Error at "++(pos $2)++": Duplicate identificator " ++ (idToStr $1) ); 
            }

ListParam : {- empty -} { 
                    $$ = []; 
                    $$.envV = [];
                    $$.typList = [];
                    } 

          | Param { 
                    $$ = (:[]) $1; 
                    $$.envV = $1.envV;
                    $$.typList = $1.typList;            
                    }

          | Param ',' ListParam { 
                    $$ = (:) $1 $3;
                    $$.envV = $1.envV ++ $3.envV;
                    $$.typList = ( $1.typList ++ $3.typList );
                    where ( case (checkVarParamList $1.envV $3.envV) of {
                        Just a  -> ( Bad $ "Sintax Error at "++(pos $2)++": Duplicate identificator "++ idToStr a );
                        Nothing -> ( Ok () );
                        } );
                    }

ListStmt : {- empty -} { 
                        $$ = []; 
                        $$.envVMod = $$.envV;
                        $$.envFMod = $$.envF;
                        $$.isReturn = False;
                        $$.tempMod = $$.temp;
                        $$.tac = [];
                        }
 
         | ListStmt Stmt { 
                        $$ = flip (:) $1 $2; 
                        $1.envV = $$.envV;
                        $1.envF = $$.envF;
                        $2.envV = $1.envVMod;
                        $2.envF = $1.envFMod;
                        $$.envVMod = $2.envVMod;
                        $$.envFMod = $2.envFMod;
                        $1.typFun = $$.typFun;
                        $2.typFun = $$.typFun;
                        $$.isReturn = $2.isReturn;
                        $1.loopLabels = $$.loopLabels;
                        $2.loopLabels = $$.loopLabels;
                        $1.temp = $$.temp;
                        $2.temp = $1.tempMod;
                        $$.tempMod = $2.tempMod;
                        $$.tac = $1.tac ++ $2.tac ;
                        }

























































{
-------------------------------------------------------------------------------------------------------------------------------
---------------------------- FUNZIONI AUSILIARIE PER INDIVIDUAZIONE E STAMPA DEGLI ERRORI -------------------------------------
-------------------------------------------------------------------------------------------------------------------------------


-- controlli di tipo sulle operazioni matematiche
checkMathOp t1 t2 e1 e2 p = if ( (e1 == "") && (e2 == "")  ) 
                 then ( if ((t1 == TInt || t1 == TFloat) && (t2 == TInt || t2 == TFloat))
                    then ""
                    else "Type Error at "++(pos p)++": Math operator expected numeric type (int or float)"
                    )
                 else if  e1/=""
                    then e1
                    else e2


-- controlli di tipo sulle operazioni relazionali
checkRelOp t1 t2 e1 e2 p = if ( (e1 == "") && (e2 == "")  ) 
                then  ( if (t1 == t2) 
                    then ""
                    else if ((t1 == TInt || t1 == TFloat) && (t2 == TInt || t2 == TFloat))
                        then ""
                        else "Type Error at "++(pos p)++": Couldn't match type "++(showType t1)++" with type "++ (showType t2)
                    )
                else if  e1/=""
                    then e1
                    else e2
            

-- controlli di tipo sulle operazioni booleane
checkBoolOp t1 t2 e1 e2 p  = if ( (e1 == "") && (e2 == "")  ) 
                then    (if (t2 == t1)
                    then    if (t1/=TBool) 
                        then "Type Error at "++(pos p)++": Expected boolean type" 
                        else ""
                    else "Type Error at "++(pos p)++": Couldn't match type "++(showType t1)++" with type "++ (showType t2)
                    )
                else  if  e1/=""
                    then e1
                    else e2


-- controlli sulle chiamate di funzioni e procedure (visibilit√† e match dei parametri)
checkErrProc id envF tl p  = if (not(searchFun id envF)) 
                    then "Scope Error at "++(pos p)++": Procedure  "++(idToStr id)++" not in scope"
                    else checkNParamFun id envF tl p  


checkErrFun e id envF tl p  = if (e=="") 
                then if not(searchFun id envF) 
                    then  "Scope Error at "++(pos p)++": Function  "++(idToStr id)++" not in scope"
                    else checkNParamFun id envF tl p  
                else e

checkNParamFun id envF tl p  =  if ( (length (getTypeListFun (extrFun id envF))) /= (length tl)  ) 
                then "Sintax Error at "++(pos p)++": Wrong n.of arguments in call of "++(idToStr id)++", expected: "++(show (length (getTypeListFun (extrFun id envF))))
                else ( case ( matchTypeList (getTypeListFun (extrFun id envF)) tl ) of {
                        Just a  -> "Type Error at "++(pos p)++": Wrong argument type, couldn't match "++(showType (fst a))++" with "++(showType (snd a))++" in function "++(idToStr id);
                        Nothing -> "";
                        } )

matchTypeList [] [] = Nothing
matchTypeList (x:xs) (y:ys) | x/=y = Just (x,y)
                            | otherwise = matchTypeList xs ys
                
matchType _ [] = Nothing
matchType x (y:ys) | x/=y = Just (x,y)
                   | otherwise = matchType x ys


-- costante moltiplicativa per l'allocazione di array (tac)
mem typ = case typ of {
        TInt -> 4;
        TFloat -> 8;
        TChar -> 2;
        TString -> 32;
        TBool -> 1;
        (TPointer _) -> 4;
        (TArray d t) -> d * (mem t);
        }


-- controlla che non ci siano variabili doppie tra parametri differenti in una definizione di funzione(procedura)
checkVarParamList [] ys = Nothing
checkVarParamList (x@(Var a _ _ _):xs) ys | (searchVar a ys) =  Just a
                    | otherwise = (checkVarParamList xs ys)

-- posizione del token 
pos tok = tokenPos [tok]

showType (TInt) =   "int"
showType (TFloat) = "float"
showType (TChar) =  "char"
showType (TString) = "string"
showType (TBool) =  "boolean"
showType (TVoid) = "void"
showType (TArray n t) = "array[] " ++ showType t
showType (TPointer t) = "*" ++ showType t


showVal (Int i) = show i
showVal (Float f) = show f
showVal (Char c)= "'"++(c:"'")
showVal (String s)= "\""++s++"\""
showVal (Bool Boolean_true)= "true"
showVal (Bool Boolean_false)= "false"

getPosV id env = case (extrVar id env) of
                     Var _ _ _ pos -> "_" ++ drop 5 pos

getPosF id env = case (extrFun id env) of
                     Fun _ _ _ pos -> "_" ++ drop 5 pos

setPos ids pos = map (\id -> Id $ (idToStr id) ++ "_" ++ drop 5 pos) ids


shift tacList n = map (\x -> shift1 x n) tacList
shift1 tacOp n = case tacOp of
                      CondJ t1 lab -> CondJ t1 (lab+n)
                      CondJTrue t1 lab -> CondJTrue t1 (lab+n)
                      x -> x

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "Syntax Error: error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

