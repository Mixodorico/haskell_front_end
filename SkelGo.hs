module SkelGo where

-- Haskell module generated by the BNF converter

import AbsGo
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transId :: Id -> Result
transId x = case x of
  Id string -> failure x
transStart :: Start -> Result
transStart x = case x of
  Entry id decls -> failure x
transDecl :: Decl -> Result
transDecl x = case x of
  DeclFun id params type_ block -> failure x
  DeclProc id params block -> failure x
  DeclVar ids type_ -> failure x
  DeclVarInit ids rexps -> failure x
transShortVarDecl :: ShortVarDecl -> Result
transShortVarDecl x = case x of
  DeclVarShort ids rexps -> failure x
transParam :: Param -> Result
transParam x = case x of
  ParamL ids type_ -> failure x
  ParamLPassType pass ids type_ -> failure x
transPass :: Pass -> Result
transPass x = case x of
  PassValue -> failure x
  PassRef -> failure x
  PassValueRes -> failure x
transType :: Type -> Result
transType x = case x of
  TypeVoid -> failure x
  TypeInt -> failure x
  TypeBool -> failure x
  TypeFloat -> failure x
  TypeChar -> failure x
  TypeString -> failure x
  TypeArray integer type_ -> failure x
  TypePointer type_ -> failure x
transBlock :: Block -> Result
transBlock x = case x of
  BodyBlock statements -> failure x
transStatement :: Statement -> Result
transStatement x = case x of
  StateBlock block -> failure x
  StateSmpl statementsmpl -> failure x
  StateReturn rexp -> failure x
  StateIf rexp block -> failure x
  StateIfElse rexp block1 block2 -> failure x
  StateIfStm statementsmpl rexp block -> failure x
  StateIfElseStm statementsmpl rexp block1 block2 -> failure x
  StateFor statementsmpls1 rexp statementsmpls2 block -> failure x
  StateWhile rexp block -> failure x
  StateDecl decl -> failure x
  StateBreak -> failure x
  StateContinue -> failure x
  StateTryCatch block1 block2 -> failure x
  StateWrite rexp -> failure x
  StateRead rexp -> failure x
transStatementSmpl :: StatementSmpl -> Result
transStatementSmpl x = case x of
  StateShortVarDecl shortvardecl -> failure x
  StateExp rexp -> failure x
  StateAsgn lexp rexp -> failure x
transLExp :: LExp -> Result
transLExp x = case x of
  ExpId id -> failure x
  ExpArr lexp rexp -> failure x
  ExpDeref rexp -> failure x
transRExp :: RExp -> Result
transRExp x = case x of
  ExpAdd rexp1 rexp2 -> failure x
  ExpSub rexp1 rexp2 -> failure x
  ExpMul rexp1 rexp2 -> failure x
  ExpDiv rexp1 rexp2 -> failure x
  ExpMod rexp1 rexp2 -> failure x
  ExpEqu rexp1 rexp2 -> failure x
  ExpNeq rexp1 rexp2 -> failure x
  ExpLes rexp1 rexp2 -> failure x
  ExpLeq rexp1 rexp2 -> failure x
  ExpGre rexp1 rexp2 -> failure x
  ExpGrq rexp1 rexp2 -> failure x
  ExpAnd rexp1 rexp2 -> failure x
  ExpOr rexp1 rexp2 -> failure x
  ExpNot rexp -> failure x
  ExpNeg rexp -> failure x
  ExpValue value -> failure x
  ExpLef lexp -> failure x
  ExpFuncEmpty id -> failure x
  ExpFunc id rexps -> failure x
  ExpRef lexp -> failure x
  ExpPar rexp -> failure x
transValue :: Value -> Result
transValue x = case x of
  Int integer -> failure x
  Float double -> failure x
  Char char -> failure x
  String string -> failure x
  Bool boolean -> failure x
transBoolean :: Boolean -> Result
transBoolean x = case x of
  BoolTrue -> failure x
  BoolFalse -> failure x

