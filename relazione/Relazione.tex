\documentclass[12pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath} 
\begin{document}

\title{\noindent \Huge Progetto Linguaggi e Compilatori 2\\ Parte 3 \\ Gruppo 1}
\date{}
\author{Studenti: \\Foschiani Luca\\ Marinato Riccardo \\Passalenti Andrea}

\maketitle
\newpage

\section{Assunzioni}
Nel seguente progetto abbiamo considerato le scelte di sintassi concreta definite dal linguaggio \textit{Go}.
A seguire vengono riassunte una serie di assunzioni.

\begin{itemize}
\item Variabili:
	\begin{itemize}
		\item non è consientito dichiarare delle variabili con lo stesso identificatore nello stesso blocco, mentre è possibile se avviene su blocchi (e sottoblocchi) diversi;
		\item non è possibile utilizzare delle right-expression isolate;
		\item è consentita la dichiarazione di variabili globali al di fuori delle funzioni, ma non tramite la sintassi ``:=".
	\end{itemize}
\item Funzioni e procedure:
	\begin{itemize}
		\item non è possibile dichiarare più di una funzione/procedura con lo stesso identificatore;
		\item nel corpo delle procedure non deve essere presente l'istruzione return, sempre richiesta invece nei corpi delle funzioni;
		\item è consentito effettuare dei passaggi di parametri per valore (\textit{val}) e per riferimento (\textit{ref}).
	\end{itemize}
\item Comandi di controllo sequenza:
	\begin{itemize}
		\item è stato usato l'operatore `!' nelle condizioni degli if per veicolare correttamente i salti condizionati;
		\item sono stati implementati solamente i comandi per il controllo della sequenza richiesti nel testo del progetto (\textit{condizionali semplici} e \textit{iterazione indeterminata});
		\item le guardie booleane dei controlli di sequenza vengono gestite tramite short-cut mentre le altre espressioni booleane vengono gestite senza short-cut;
		\item non è possibile definire controlli di sequenza al di fuori delle funzioni/procedure.
	\end{itemize}
\end{itemize}

\section{Scelte implementative}
\begin{itemize}
\item Abbiamo generato \textit{lexer} e \textit{parser} tramite il tool BNFC, partendo dalla definizione di una gramatica iniziale;
\item la gestione del \textit{Type Checker} e del \textit{Three Address Code} vengono fatte all'interno del parser;
\item le funzioni \textit{write} sono trattate come statement che prendendono come argomento una right-expression, mentre le funzioni \textit{read} vengono viste come right-expressions e hanno una lista di parametri di input vuota.
\end{itemize}

\section{Grammatica}
Di seguito viene riportata la grammatica di partenza.
\begin{verbatim}
comment "//";
comment "/*" "*/";

entrypoints Start;

rules     Boolean ::= "true" | "false" ;

ExpAnd.        RExp ::= RExp "&&" RExp ;
ExpOr.         RExp ::= RExp "||" RExp ;
ExpNot.        RExp ::= "!" RExp ;        
ExpEq.         RExp ::= RExp "==" RExp ;
ExpNeq.        RExp ::= RExp "!=" RExp ;
ExpLt.         RExp ::= RExp "<" RExp ;
ExpLtE.        RExp ::= RExp "<=" RExp ;
ExpGt.         RExp ::= RExp ">" RExp ;
ExpGtE.        RExp ::= RExp ">=" RExp ;
ExpAdd.        RExp ::= RExp "+" RExp ;
ExpSub.        RExp ::= RExp "-" RExp ;
ExpMul.        RExp ::= RExp "*" RExp ;
ExpDiv.        RExp ::= RExp "/" RExp ;
ExpMod.        RExp ::= RExp "%" RExp ;
ExpNeg.        RExp ::= "-" RExp ;
ExpRef.        RExp ::= "&" LExp ;
ExpFuncEmpty.  RExp ::= Id "(" ")" ;
ExpFunc.       RExp ::= Id "(" [RExp] ")" ;
ExpVal.        RExp ::= Val ;
ExpLExp.       RExp ::= LExp ;
ExpPar.        RExp ::= "(" RExp ")";
StRead.        RExp ::= ReadT "(" ")";

Int .          Val ::= Integer ;
Float .        Val ::= Double ;
Char .         Val  ::= Char ;
String .       Val ::= String ;
Bool .         Val  ::= Boolean ;

rules     ReadT  ::= "readInt" | "readFloat" | "readChar" | "readString" ;

ExpId.    LExp ::= Id ;
ExpArr.   LExp ::= LExp "[" RExp "]" ;
ExpDeref. LExp ::= "*" RExp ;

separator nonempty RExp "," ;

Entry.          Start ::= "package" Id [Decl];

separator Decl "";

DeclVar.         Decl ::= "var"  [Id] Type;
DeclVarInit.     Decl ::= "var"  [Id] "=" [RExp];
DeclVarTypeInit. Decl ::= "var"  [Id] Type "=" [RExp];
DeclVarShort.    ShortVarDecl ::= [Id] ":=" [RExp];

TVoid.           Type ::= "void";
TInt.            Type ::= "int";
TBool.           Type ::= "bool";
TFloat.          Type ::= "float";
TChar.           Type ::= "char";
TString.         Type ::= "string";
TArray.          Type ::=  "[" Integer "]" Type; 
TPointer.        Type ::= "*" Type; 

token Id (letter | '_')(letter | digit | '_')*;

separator Param ",";

DeclFun.         Decl ::= "func" Id "(" [Param] ")" Type Block;
DeclProc.        Decl ::= "func" Id "(" [Param] ")" "void" Block;

separator nonempty Id ",";

Parameter.        Param ::=  [Id] Type;
ParameterPass.    Param ::=  Pass [Id] Type;

PassVal.          Pass  ::=  "val";
PassRef.          Pass  ::=  "ref";

separator Stmt "";

BodyBlock. Block ::= "{" [Stmt] "}";

StDecl.           Stmt ::= Decl;
StBlock.          Stmt ::= Block;
StSmpl.           Stmt ::= StmtSmpl;
StIf.             Stmt ::= "if" RExp Block;
StIfElse.         Stmt ::= "if" RExp Block "else" Block;
StWhile.          Stmt ::= "for" RExp Block;
StBreak.          Stmt ::= "break"; 
StContinue.       Stmt ::= "continue";
StReturn.         Stmt ::= "return" RExp;
StWrite.          Stmt ::= WriteT "(" RExp ")";

rules WriteT ::= "writeInt" | "writeFloat" | "writeChar" | "writeString";

StShortVarDecl.   StmtSmpl ::= ShortVarDecl;
StExp.            StmtSmpl ::= RExp;
StAsgn.           StmtSmpl ::= LExp "=" RExp;
\end{verbatim}

\section{Parser}
Gran parte del progetto è stato sviluppato all'interno del parser. In particolare tutta la parte di \textit{type checking} e \textit{three address code} sono state implementate al suo interno.\\
All'iterno del parser sono stati definiti tutta una serie di attributi relativi alla \textit{grammatica attributata}.
Gli enviroment sono gestiti attraverso gli attributi \textit{EnvVar}/\textit{EnvVarNew} ed \textit{EnvFun}/\textit{EnvFunNew} e corrispondono a liste di tipi di dato \textit{ElemVar} ed \textit{ElemFun}. In particolare, gli attributi \textit{EnvVar} ed \textit{EnvFun} rappresentano, per ogni nodo, l'ambiente  derivante dal nodo padre, mentre \textit{EnvVarNew} ed \textit{EnvFunNew} definiscono l'ambiente ottenuto da tutti i nodi figli.
Sono stati inoltre definiti ulteriori attributi per gestire la generazione del three address code (si rimanda al codice).\\
Per quanto riguarda la dichiarazione delle precedenze e l'associatività degli operatori, sono tutte state gestite a livello di parser.

\subsection{Type Checker}
Il Type Checker viene gestito interamente all'interno del parser. In particolare per ogni espressione valutata si effettua un controllo diretto attraverso le funzioni \textit{Ok} e \textit{Bad} che, in caso di errore, gestiscono l'errore tramite la stampa di un messaggio a video indicante la linea dell'errore e la causa.\\
Tutte le funzioni di controllo utilizzate dal Type Checker sono state definite internamente al parser per praticità.\\
Tra le diverse assunzioni fatte in fase di type checking, abbiamo voluto tenere conto in modo automatico di una conversione dal tipo int al tipo float.

\subsection{Three Address Code}
Il Three Address Code viene generato interamente nel parser, utilizzando un modulo esterno (\textit{TAC.hs}) contenente la struttura dati per gestirne la generazione e le funzioni addette alla stampa. Inoltre ci siamo appoggiati su un ulteriore modulo (\textit{Env.hs}) contenete tutte le funzioni per la gestione dell'environment (inserimento, cancellazione e ricerca di variabili/funzioni).
In questo modulo sono stati dichiarati i tipi di dato \textit{ElemVar} e \textit{ElemFun} contenenti rispettivamente tutte le informazioni relative alle variabili ed alle funzioni/procedure dichiarate nell'ambiente.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% le etichette davanti al dfrac non so se occorrono o meno...
% per evitare errori si potrebbero omettere forse?
% ho considerato prevalentemente pruteanu, de nart(si, si anche lui) e martu
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Type System}
A seguire il \textit{Type System} relativo al linguaggio implementato.
\subsection*{Basic Judgments}
\begin{center}
$\Gamma$ è un ambiente ben formato:\\
$\Gamma \vdash \diamond$\\[0.1in]
\textit{Type} è un tipo ben formato in $\Gamma$\\
$\Gamma \vdash $\textit{Type}\\[0.1in]
\textit{Stmt} è un tipo ben formato in $\Gamma$\\
$\Gamma \vdash $\textit{Stmt}\\[0.1in]
\textit{RExp} è un tipo ben formato in $\Gamma$\\
$\Gamma \vdash $\textit{RExp : Type}\\[0.1in]
\end{center}

\subsection*{Rules}
\begin{center}
\noindent (\textbf{empty})
$\dfrac{}{\emptyset \vdash \diamond}$\\[0.2in]
%\noindent(Entry)
%$\dfrac{}{}$\\[0.1in]
\noindent (\textbf{Id})
$\dfrac{\Gamma \vdash \diamond , Ident \not\in dom(\Gamma)}{\Gamma , Ident \vdash \diamond}$\\[0.1in]
\end{center}

\subsubsection*{Basic Types}
\begin{center}
\noindent(\textbf{Int})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash n : Int}$\\[0.1in]
\noindent(\textbf{Float})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash f : Float}$\\[0.1in]
\noindent(\textbf{Char})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash c : Char}$\\[0.1in]
\noindent(\textbf{String})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash s : String}$\\[0.1in]
\noindent(\textbf{True})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash true : Boolean}$\\[0.1in]
\noindent(\textbf{False})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash false : Boolean}$\\[0.1in]
\end{center}

\subsubsection*{Functions}
\begin{center}
\noindent(\textbf{And})
$\dfrac{\Gamma \vdash RExp1:Boolean\ \ \ \Gamma \vdash RExp2:Boolean}{\Gamma \vdash RExp1\ and\ RExp2:Boolean}$\\[0.1in]
\noindent(\textbf{Or})
$\dfrac{\Gamma \vdash RExp1:Boolean\ \ \ \Gamma \vdash RExp2:Boolean}{\Gamma \vdash RExp1\ or\ RExp2:Boolean}$\\[0.1in]
\noindent(\textbf{Not})
$\dfrac{\Gamma \vdash RExp:Boolean}{\Gamma \vdash not\  RExp:Boolean}$\\[0.1in]

\noindent(\textbf{Eq})
$\dfrac{\Gamma \vdash RExp1:Type\ \ \ \Gamma \vdash RExp2:Type}{\Gamma \vdash RExp1\ ==\ RExp2:Boolean}$\\[0.1in]
\noindent(\textbf{Neq})
$\dfrac{\Gamma \vdash RExp1:Type\ \ \ \Gamma \vdash RExp2:Type}{\Gamma \vdash RExp1\ !=\ RExp2:Boolean}$\\[0.1in]
\noindent(\textbf{Lt})
$\dfrac{\Gamma \vdash RExp1:Type\ \ \ \Gamma \vdash RExp2:Type}{\Gamma \vdash RExp1\ <\ RExp2:Boolean}$\\[0.1in]
\noindent(\textbf{LtE})
$\dfrac{\Gamma \vdash RExp1:Type\ \ \ \Gamma \vdash RExp2:Type}{\Gamma \vdash RExp1\ <=\ RExp2:Boolean}$\\[0.1in]
\noindent(\textbf{Gt})
$\dfrac{\Gamma \vdash RExp1:Type\ \ \ \Gamma \vdash RExp2:Type}{\Gamma \vdash RExp1\ >\ RExp2:Boolean}$\\[0.1in]
\noindent(\textbf{GtE})
$\dfrac{\Gamma \vdash RExp1:Type\ \ \ \Gamma \vdash RExp2:Type}{\Gamma \vdash RExp1\ >=\ RExp2:Boolean}$\\[0.1in]

\noindent(\textbf{Add 1})
$\dfrac{\Gamma \vdash RExp1:Int\ \ \ \Gamma \vdash RExp2:Int}{\Gamma \vdash RExp1\ +\ RExp2:Int}$\\[0.1in]
\noindent(\textbf{Add 2})
$\dfrac{\Gamma \vdash RExp1:Int\ \ \ \Gamma \vdash RExp2:Float}{\Gamma \vdash RExp1\ +\ RExp2:Float}$\\[0.1in]
\noindent(\textbf{Add 3})
$\dfrac{\Gamma \vdash RExp1:Float\ \ \ \Gamma \vdash RExp2:Int}{\Gamma \vdash RExp1\ +\ RExp2:Float}$\\[0.1in]
\noindent(\textbf{Add 4})
$\dfrac{\Gamma \vdash RExp1:Float\ \ \ \Gamma \vdash RExp2:Float}{\Gamma \vdash RExp1\ +\ RExp2:Float}$\\[0.1in]

\noindent(\textbf{Sub 1})
$\dfrac{\Gamma \vdash RExp1:Int\ \ \ \Gamma \vdash RExp2:Int}{\Gamma \vdash RExp1\ -\ RExp2:Int}$\\[0.1in]
\noindent(\textbf{Sub 2})
$\dfrac{\Gamma \vdash RExp1:Int\ \ \ \Gamma \vdash RExp2:Float}{\Gamma \vdash RExp1\ -\ RExp2:Float}$\\[0.1in]
\noindent(\textbf{Sub 3})
$\dfrac{\Gamma \vdash RExp1:Float\ \ \ \Gamma \vdash RExp2:Int}{\Gamma \vdash RExp1\ -\ RExp2:Float}$\\[0.1in]
\noindent(\textbf{Sub 4})
$\dfrac{\Gamma \vdash RExp1:Float\ \ \ \Gamma \vdash RExp2:Float}{\Gamma \vdash RExp1\ -\ RExp2:Float}$\\[0.1in]

\noindent(\textbf{Mul 1})
$\dfrac{\Gamma \vdash RExp1:Int\ \ \ \Gamma \vdash RExp2:Int}{\Gamma \vdash RExp1\ *\ RExp2:Int}$\\[0.1in]
\noindent(\textbf{Mul 2})
$\dfrac{\Gamma \vdash RExp1:Int\ \ \ \Gamma \vdash RExp2:Float}{\Gamma \vdash RExp1\ *\ RExp2:Float}$\\[0.1in]
\noindent(\textbf{Mul 3})
$\dfrac{\Gamma \vdash RExp1:Float\ \ \ \Gamma \vdash RExp2:Int}{\Gamma \vdash RExp1\ *\ RExp2:Float}$\\[0.1in]
\noindent(\textbf{Mul 4})
$\dfrac{\Gamma \vdash RExp1:Float\ \ \ \Gamma \vdash RExp2:Float}{\Gamma \vdash RExp1\ *\ RExp2:Float}$\\[0.1in]

\noindent(\textbf{Div 1})
$\dfrac{\Gamma \vdash RExp1:Int\ \ \ \Gamma \vdash RExp2:Int}{\Gamma \vdash RExp1\ /\ RExp2:Int}$\\[0.1in]
\noindent(\textbf{Div 2})
$\dfrac{\Gamma \vdash RExp1:Int\ \ \ \Gamma \vdash RExp2:Float}{\Gamma \vdash RExp1\ /\ RExp2:Float}$\\[0.1in]
\noindent(\textbf{Div 3})
$\dfrac{\Gamma \vdash RExp1:Float\ \ \ \Gamma \vdash RExp2:Int}{\Gamma \vdash RExp1\ /\ RExp2:Float}$\\[0.1in]
\noindent(\textbf{Div 4})
$\dfrac{\Gamma \vdash RExp1:Float\ \ \ \Gamma \vdash RExp2:Float}{\Gamma \vdash RExp1\ /\ RExp2:Float}$\\[0.1in]
\noindent(\textbf{Mod})
$\dfrac{\Gamma \vdash RExp1:Int\ \ \ \Gamma \vdash RExp2:Int}{\Gamma \vdash RExp1\ \%\ RExp2:Int}$\\[0.1in]
\noindent(\textbf{Neg 1})
$\dfrac{\Gamma \vdash RExp:Int}{\Gamma \vdash -RExp:Int}$\\[0.1in]
\noindent(\textbf{Neg 2})
$\dfrac{\Gamma \vdash RExp:Float}{\Gamma \vdash -RExp:Float}$\\[0.1in]

\noindent(\textbf{Ref})
$\dfrac{\Gamma \vdash Ident}{\Gamma \vdash \text{\&} Ident}$\\[0.1in]
\noindent(\textbf{Deref})
$\dfrac{\Gamma \vdash Type}{\Gamma \vdash \text{*} Type}$\\[0.1in]

\noindent(\textbf{Asgn})
$\dfrac{\Gamma \vdash LExp:Type\ \ \ \Gamma \vdash RExp:Type}{\Gamma \vdash LExp = RExp}$\\[0.1in]

\noindent(\textbf{If})
$\dfrac{\Gamma \vdash RExp:Boolean\ \ \ \Gamma \vdash Block}{\Gamma \vdash if\ RExp\ \{ Block\}}$\\[0.1in]
\noindent(\textbf{IfElse})
$\dfrac{\Gamma \vdash RExp:Boolean\ \ \ \Gamma \vdash Block1\ \ \ \Gamma \vdash Block2}{\Gamma \vdash if\ RExp\ \{ Block1\}\ else\ \{ Block1\}}$\\[0.1in]
\noindent(\textbf{While})
$\dfrac{\Gamma \vdash RExp:Boolean\ \ \ \Gamma \vdash Block}{\Gamma \vdash for\ RExp\ \{ Block\}}$\\[0.1in]

\noindent(\textbf{DeclFun})
$\dfrac{\Gamma \vdash Ident\ \ \ \Gamma \vdash Params:[Type]\ \ \ \Gamma \vdash Block}{\Gamma \vdash func\ Ident ([Type])\ Type\ \{Block\}}$\\[0.1in]
\noindent(\textbf{DeclProc})
$\dfrac{\Gamma \vdash Ident\ \ \ \Gamma \vdash Params:[Type]\ \ \ \Gamma \vdash Block}{\Gamma \vdash func\ Ident ([Type])\ void\ \{Block\}}$\\[0.1in]
\end{center}





\pagebreak
\section{Test Case}
Sono stati preparati dei test-case significativi che possono essere eseguiti in sequenza attraverso il comando \textit{make demo}, oppure singolarmente attraverso i comandi \textit{make demo1}, \textit{make demo2}, \textit{make demo3} e \textit{make demo4}.

\end{document}
