\documentclass[12pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath} 
\begin{document}

\title{\noindent \Huge Progetto Linguaggi e Compilatori 2\\ Parte 3 \\ Gruppo 1}
\date{}
\author{Studenti: \\Foschiani Luca\\ Marinato Riccardo \\Passalenti Andrea}

\maketitle
\newpage

\section{Assunzioni}
Nel seguente progetto abbiamo considerato le scelte di sintassi concreta definite dal linguaggio \textit{Go}.
A seguire vengono riassunte una serie di assunzioni.

\begin{itemize}
\item Variabili e operazioni:
	\begin{itemize}
		\item non è consientito dichiarare delle variabili con lo stesso identificatore nello stesso blocco, mentre è possibile se avviene su blocchi (e sottoblocchi) diversi;
		\item non è possibile utilizzare delle right-expression isolate;
		\item è consentita la dichiarazione di variabili globali al di fuori delle funzioni, ma non tramite la sintassi ``:=";
		\item sono resi compatibili i seguenti tipi:
		\begin{itemize}
			\item \textit{float} $\leftarrow$ \textit{interi}
			\item \textit{interi} $\leftarrow$ \textit{booleani}
			\item \textit{float} $\leftarrow$ \textit{booleani}
		\end{itemize}
	\end{itemize}
\item Funzioni e procedure:
	\begin{itemize}
		\item non è possibile dichiarare più di una funzione/procedura con lo stesso identificatore;
		\item nel corpo delle procedure non deve essere presente l'istruzione return, sempre richiesta invece nei corpi delle funzioni;
		\item è consentito effettuare dei passaggi di parametri per valore (\textit{val}) e per riferimento (\textit{ref}).
	\end{itemize}
\item Comandi di controllo sequenza:
	\begin{itemize}
		\item è stato usato l'operatore `!' nelle condizioni degli if per veicolare correttamente i salti condizionati;
		\item sono stati implementati i comandi per il controllo della sequenza richiesti nel testo del progetto (\textit{condizionali semplici}, \textit{iterazione determinata} (costrutto for) \textit{e indeterminata} (nelle sue due forme:  while-do e do-while)). Per riferirci ai costrutti di iterazione useremo sempre l'etichetta "\textit{for}";
		\item le guardie booleane dei controlli di sequenza vengono gestite tramite short-cut mentre le altre espressioni booleane vengono gestite senza short-cut;
		\item non è possibile definire controlli di sequenza al di fuori delle funzioni/procedure;
		\item è stato implementato il costrutto \textit{try-catch} che nei suoi argomenti accetta una lista di statement.
	\end{itemize}
\end{itemize}

\section{Scelte implementative}
\begin{itemize}
\item Abbiamo generato \textit{lexer} e \textit{parser} tramite il tool BNFC, partendo dalla definizione di una gramatica iniziale;
\item la gestione del \textit{Type Checker} e del \textit{Three Address Code} vengono fatte all'interno del parser;
\item le funzioni \textit{write} sono trattate come statement che prendendono come argomento una right-expression, mentre le funzioni \textit{read} vengono viste come right-expressions e hanno una lista di parametri di input vuota.
\end{itemize}

\section{Grammatica}
Di seguito viene riportata la grammatica di partenza.
\begin{verbatim}
comment "//";
comment "/*" "*/";

entrypoints Start;

rules Boolean ::= "true" | "false";

ExpAnd.          RExp ::= RExp "&&" RExp;
ExpOr.           RExp ::= RExp "||" RExp;
ExpNot.          RExp ::= "!" RExp; 
ExpEq.           RExp ::= RExp "==" RExp;
ExpNeq.          RExp ::= RExp "!=" RExp;
ExpLt.           RExp ::= RExp "<" RExp;
ExpLtE.          RExp ::= RExp "<=" RExp;
ExpGt.           RExp ::= RExp ">" RExp;
ExpGtE.          RExp ::= RExp ">=" RExp;
ExpAdd.          RExp ::= RExp "+" RExp;
ExpSub.          RExp ::= RExp "-" RExp;
ExpMul.          RExp ::= RExp "*" RExp;
ExpDiv.          RExp ::= RExp "/" RExp;
ExpMod.          RExp ::= RExp "%" RExp;
ExpNeg.          RExp ::= "-" RExp;
ExpRef.          RExp ::= "&" LExp;
ExpFuncEmpty.    RExp ::= Id "(" ")";
ExpFunc.         RExp ::= Id "(" [RExp] ")";
ExpVal.          RExp ::= Val;
ExpLExp.         RExp ::= LExp;
ExpPar.          RExp ::= "(" RExp ")";
StRead.          RExp ::= ReadT "(" ")";

Int .            Val ::= Integer;
Float .          Val ::= Double;
Char .           Val  ::= Char;
String .         Val ::= String;
Bool .           Val  ::= Boolean;

rules ReadT  ::= "readInt" | "readFloat" | "readChar" | "readString";

ExpId.           LExp ::= Id;
ExpArr.          LExp ::= LExp "[" RExp "]";
ExpDeref.        LExp ::= "*" RExp;

separator nonempty RExp ",";

Entry.           Start ::= "package" Id [Decl];

separator Decl "";

DeclVar.         Decl ::= "var"  [Id] Type;
DeclVarInit.     Decl ::= "var"  [Id] "=" [RExp];
DeclVarTypeInit. Decl ::= "var"  [Id] Type "=" [RExp];
DeclVarShort.    ShortVarDecl ::= [Id] ":=" [RExp];

TVoid.           Type ::= "void";
TInt.            Type ::= "int";
TBool.           Type ::= "bool";
TFloat.          Type ::= "float";
TChar.           Type ::= "char";
TString.         Type ::= "string";
TArray.          Type ::=  "[" Integer "]" Type; 
TPointer.        Type ::= "*" Type; 

token Id (letter | '_')(letter | digit | '_')*;
separator nonempty Id "," ;

DeclFun.         Decl ::= "func" Id "(" [Param] ")" Type Block;
DeclProc.        Decl ::= "func" Id "(" [Param] ")" "void" Block;

separator Param ",";

Parameter.       Param ::=  [Id] Type;
ParameterPass.   Param ::=  Pass [Id] Type;

PassVal.         Pass  ::=  "val";
PassRef.         Pass  ::=  "ref";

separator Stmt "";

BodyBlock.       Block ::= "{" [Stmt] "}";

StDecl.          Stmt ::= Decl;
StBlock.         Stmt ::= Block;
StSmpl.          Stmt ::= StmtSmpl;
StIf.            Stmt ::= "if" RExp Block;
StIfElse.        Stmt ::= "if" RExp Block "else" Block;
StWhile.         Stmt ::= "for" RExp Block;
StDoWhile.       Stmt ::= "do" Block "for" RExp;
StFor.           Stmt ::= "for" [StmtSmpl] ";" RExp ";" [StmtSmpl] Block;
StBreak.         Stmt ::= "break";
StContinue.      Stmt ::= "continue";
StReturn.        Stmt ::= "return" RExp;
StTryCatch.      Stmt ::= "try" Stmt "catch" Stmt;
StWrite.         Stmt ::= WriteT "(" RExp ")";

rules WriteT ::= "writeInt" | "writeFloat" | "writeChar" | "writeString";

StShortVarDecl.  StmtSmpl ::= ShortVarDecl;
StExp.           StmtSmpl ::= RExp;
StAsgn.          StmtSmpl ::= LExp "=" RExp;

[].             [StmtSmpl] ::= ;
(:[]).          [StmtSmpl] ::= StmtSmpl;
\end{verbatim}

\section{Parser}
Gran parte del progetto è stato sviluppato all'interno del parser. In particolare tutta la parte di \textit{type checking} e \textit{three address code} sono state implementate al suo interno.\\
All'iterno del parser sono stati definiti tutta una serie di attributi relativi alla \textit{grammatica attributata}.
Gli enviroment sono gestiti attraverso gli attributi \textit{EnvVar}/\textit{EnvVarNew} ed \textit{EnvFun}/\textit{EnvFunNew} e corrispondono a liste di tipi di dato \textit{ElemVar} ed \textit{ElemFun}. In particolare, gli attributi \textit{EnvVar} ed \textit{EnvFun} rappresentano, per ogni nodo, l'ambiente  derivante dal nodo padre, mentre \textit{EnvVarNew} ed \textit{EnvFunNew} definiscono l'ambiente ottenuto da tutti i nodi figli.
Sono stati inoltre definiti ulteriori attributi per gestire la generazione del three address code (si rimanda al codice).\\
Per quanto riguarda la dichiarazione delle precedenze e l'associatività degli operatori, sono tutte state gestite a livello di parser.

\subsection{Type Checker}
Il Type Checker viene gestito interamente all'interno del parser. In particolare per ogni espressione valutata si effettua un controllo diretto attraverso le funzioni \textit{Ok} e \textit{Bad} che, in caso di errore, gestiscono l'errore tramite la stampa di un messaggio a video indicante la linea dell'errore e la causa.\\
Tutte le funzioni di controllo utilizzate dal Type Checker sono state definite internamente al parser per praticità.\\
Tra le diverse assunzioni fatte in fase di type checking, abbiamo voluto tenere conto in modo automatico di una conversione dal tipo int al tipo float.

\subsection{Three Address Code}
Il Three Address Code viene generato interamente nel parser, utilizzando un modulo esterno (\textit{TAC.hs}) contenente la struttura dati per gestirne la generazione e le funzioni addette alla stampa. Inoltre ci siamo appoggiati su un ulteriore modulo (\textit{Env.hs}) contenete tutte le funzioni per la gestione dell'environment (inserimento, cancellazione e ricerca di variabili/funzioni).
In questo modulo sono stati dichiarati i tipi di dato \textit{ElemVar} e \textit{ElemFun} contenenti rispettivamente tutte le informazioni relative alle variabili ed alle funzioni/procedure dichiarate nell'ambiente.\\
I casting vengono stampati a video in fase di asegnamento.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% andrebbe bool e non boolean?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Type System}
A seguire il \textit{Type System} relativo al linguaggio implementato. Si è posta particolare attenzione è quello di definire un type system il più possibile vicino a quello del linguaggio \textit{Go}, integrando ulteriori specifiche presenti nella consegna del progetto.
Definiamo $\Gamma$ essere l'ambiente e $\tau$ essere l'insieme dei tipi di base da noi considerati: \texttt{int, float, char, string} e \texttt{boolean}.

\subsection*{Basic Judgments}
\begin{center}
$\Gamma$ è un ambiente ben formato:\\
$\Gamma \vdash \diamond$\\[0.1in]
Type è un tipo ben formato in $\Gamma$\\
$\Gamma \vdash $ Type\\[0.1in]
Stmt è un tipo ben formato in $\Gamma$\\
$\Gamma \vdash $ Stmt\\[0.1in]
RExp è un tipo ben formato in $\Gamma$\\
$\Gamma \vdash $ RExp : Type\\[0.1in]
\end{center}

\subsection*{Regole}
\begin{center}
\noindent (\textbf{empty})
$\dfrac{}{\emptyset \vdash \diamond}$\\[0.2in]
%\noindent(Entry)
%$\dfrac{}{}$\\[0.1in]
\noindent (\textbf{Id})
$\dfrac{\Gamma \vdash \diamond , \texttt{\texttt{ident}} \not\in dom(\Gamma)}{\Gamma, \texttt{\texttt{ident}} \vdash \diamond}$\\[0.1in]
\end{center}
\subsection*{Tipi Base}
Vediamo di seguito in maniera esplicita tutti i tipi considerati.
\begin{center}
\noindent(\textbf{Int})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash n : \texttt{int}}$\\[0.1in]
\noindent(\textbf{Float})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash f : \texttt{float}}$\\[0.1in]
\noindent(\textbf{Char})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash c : \texttt{char}}$\\[0.1in]
\noindent(\textbf{String})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash s : \texttt{string}}$\\[0.1in]
\noindent(\textbf{Boolean})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash b : \texttt{boolean}}$\\[0.1in]
%$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash true : Boolean}$\\[0.1in]
%\noindent(\textbf{False})
%$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash false : Boolean}$\\[0.1in]
\end{center}

\subsection*{Tipi Composti}

\begin{center}
\noindent(\textbf{Ref})
$\dfrac{\Gamma \vdash \texttt{\texttt{ident}}}{\Gamma \vdash \text{\&} \texttt{\texttt{ident}}}$\\[0.1in]
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int, float, char, string, boolean} \}
\end{itemize}
\noindent(\textbf{Deref})
$\dfrac{\Gamma \vdash \tau}{\Gamma \vdash \text{*} \tau}$\\[0.1in]
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int} \}
\end{itemize}
\noindent(\textbf{Arr})
$\dfrac{\Gamma \vdash \texttt{\texttt{ident}}\ \ \ \Gamma \vdash RExp:\tau}{\Gamma \vdash \texttt{ident}\ [\ RExp\ ]}$\\[0.1in]
\end{center}

\subsection*{Operazioni Relazionali}
\begin{center}
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{boolean} \}
\end{itemize}
\noindent(\textbf{And})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{\&\&} \ RExp2:\tau}$\\[0.1in]
\noindent(\textbf{Or})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{||} \ RExp2:\tau}$\\[0.1in]
\noindent(\textbf{Not})
$\dfrac{\Gamma \vdash RExp:\tau}{\Gamma \vdash \texttt{not}\  RExp:\tau}$\\[0.1in]

\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int, float, char, string, boolean} \}
\end{itemize}
\noindent(\textbf{Eq})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{==}\ RExp2:\texttt{boolean}}$\\[0.1in]
\noindent(\textbf{Neq})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{!=}\ RExp2:\texttt{boolean}}$\\[0.1in]
\noindent(\textbf{Lt})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{<}\ RExp2:\texttt{boolean}}$\\[0.1in]
\noindent(\textbf{LtE})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{<=}\ RExp2:\texttt{boolean}}$\\[0.1in]
\noindent(\textbf{Gt})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{>}\ RExp2:\texttt{boolean}}$\\[0.1in]
\noindent(\textbf{GtE})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{>=}\ RExp2:\texttt{boolean}}$\\[0.1in]
\end{center}

\subsection*{Operazioni Aritmetiche}
\subsubsection*{Addizione}

\begin{center}

\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{boolean} \}
\end{itemize}
\noindent(\textbf{Add 1})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{+}\ RExp2:\tau}$\\[0.1in]

\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int} \}
\end{itemize}
\noindent(\textbf{Add 2})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{+}\ RExp2:\tau}$\\[0.1in]

\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{float} \}
\end{itemize}
\noindent(\textbf{Add 3})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{+}\ RExp2:\tau}$\\[0.1in]
\end{center}
\subsubsection*{Addizione con casting implicito}
\begin{center}
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{bool, int} \} e almeno uno delle due espressioni \texttt{int}
\end{itemize}
\noindent(\textbf{Add 4})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{+}\ RExp2:\texttt{int}}$\\[0.1in]
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{bool, float} \} e almeno uno delle due espressioni \texttt{float}
\end{itemize}

\noindent(\textbf{Add 5})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{+}\ RExp2:\texttt{float}}$\\[0.1in]
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int, float} \} e almeno uno delle due espressioni \texttt{float}
\end{itemize}
\noindent(\textbf{Add 6})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{+}\ RExp2:\texttt{float}}$\\[0.1in]
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Sottrazione}

\begin{center}

\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{boolean} \}
\end{itemize}
\noindent(\textbf{Sub 1})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{-}\ RExp2:\tau}$\\[0.1in]

\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int} \}
\end{itemize}
\noindent(\textbf{Sub 2})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{-}\ RExp2:\tau}$\\[0.1in]

\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{float} \}
\end{itemize}
\noindent(\textbf{Sub 3})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{-}\ RExp2:\tau}$\\[0.1in]
\end{center}
\subsubsection*{Sottrazione con casting implicito}
\begin{center}
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{bool, int} \} e almeno uno delle due espressioni \texttt{int}
\end{itemize}
\noindent(\textbf{Sub 4})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{-}\ RExp2:\texttt{int}}$\\[0.1in]
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{bool, float} \} e almeno uno delle due espressioni \texttt{float}
\end{itemize}

\noindent(\textbf{Sub 5})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{-}\ RExp2:\texttt{float}}$\\[0.1in]
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int, float} \} e almeno uno delle due espressioni \texttt{float}
\end{itemize}
\noindent(\textbf{Sub 6})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{-}\ RExp2:\texttt{float}}$\\[0.1in]
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5

\subsubsection*{Moltiplicazione}
\begin{center}

\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{boolean} \}
\end{itemize}
\noindent(\textbf{Mul 1})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{*}\ RExp2:\tau}$\\[0.1in]

\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int} \}
\end{itemize}
\noindent(\textbf{Mul 2})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{*}\ RExp2:\tau}$\\[0.1in]

\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{float} \}
\end{itemize}
\noindent(\textbf{Mul 3})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{*}\ RExp2:\tau}$\\[0.1in]
\end{center}

\subsubsection*{Moltiplicazione con casting implicito}

\begin{center}
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{bool, int} \} e almeno uno delle due espressioni \texttt{int}
\end{itemize}
\noindent(\textbf{Mul 4})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{*}\ RExp2:\texttt{int}}$\\[0.1in]
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{bool, float} \} e almeno uno delle due espressioni \texttt{float}
\end{itemize}

\noindent(\textbf{Mul 5})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{*}\ RExp2:\texttt{float}}$\\[0.1in]
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int, float} \} e almeno uno delle due espressioni \texttt{float}
\end{itemize}
\noindent(\textbf{Mul 6})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{*}\ RExp2:\texttt{float}}$\\[0.1in]
\end{center}

\subsubsection*{Divisione}
\begin{center}

\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{boolean} \}
\end{itemize}
\noindent(\textbf{Div 1})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{/}\ RExp2:\tau}$\\[0.1in]

\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int} \}
\end{itemize}
\noindent(\textbf{Div 2})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{/}\ RExp2:\tau}$\\[0.1in]

\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{float} \}
\end{itemize}
\noindent(\textbf{Div 3})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{/}\ RExp2:\tau}$\\[0.1in]
\end{center}

\subsubsection*{Divisione con casting implicito}

\begin{center}
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{bool, int} \} e almeno uno delle due espressioni \texttt{int}
\end{itemize}
\noindent(\textbf{Div 4})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{/}\ RExp2:\texttt{int}}$\\[0.1in]
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{bool, float} \} e almeno uno delle due espressioni \texttt{float}
\end{itemize}

\noindent(\textbf{Div 5})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{/}\ RExp2:\texttt{float}}$\\[0.1in]
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int, float} \} e almeno uno delle due espressioni \texttt{float}
\end{itemize}
\noindent(\textbf{Div 6})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{/}\ RExp2:\texttt{float}}$
\end{center}
\subsubsection*{Modulo}
\begin{center}
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int} \}
\end{itemize}
\noindent(\textbf{Mod})
$\dfrac{\Gamma \vdash RExp1:\tau\ \ \ \Gamma \vdash RExp2:\tau}{\Gamma \vdash RExp1\ \texttt{\%}\ RExp2:\tau}$
\end{center}
\subsubsection*{Interi Negativi}

\begin{center}
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int} \}
\end{itemize}
\noindent(\textbf{Neg 1})
$\dfrac{\Gamma \vdash RExp:\tau}{\Gamma \vdash \texttt{-}RExp:\tau}$\\[0.1in]
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{float} \}
\end{itemize}
\noindent(\textbf{Neg 2})
$\dfrac{\Gamma \vdash RExp:\tau}{\Gamma \vdash \texttt{-}RExp:\tau}$
\end{center}

\subsection*{Controlli di sequenza}


\subsubsection*{If-then}
\begin{center}
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{boolean} \}
\end{itemize}
\noindent(\textbf{If})
$\dfrac{\Gamma \vdash RExp:\tau\ \ \ \Gamma \vdash Block}{\Gamma \vdash \texttt{if}\ RExp\ \{ Block\}}$\\[0.1in]
\end{center}

\subsubsection*{If-then-else}
\begin{center}
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{boolean} \}
\end{itemize}
\noindent(\textbf{IfElse})
$\dfrac{\Gamma \vdash RExp:\tau\ \ \ \Gamma \vdash Block1\ \ \ \Gamma \vdash Block2}{\Gamma \vdash \texttt{if}\ RExp\ \{ Block1\}\ \texttt{else}\ \{ Block1\}}$\\[0.1in]
\end{center}

\subsubsection*{While-do}
\begin{center}
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{boolean} \}
\end{itemize}
\noindent(\textbf{WhileDo})
$\dfrac{\Gamma \vdash RExp:\tau\ \ \ \Gamma \vdash Block}{\Gamma \vdash \texttt{for}\ RExp\ \{ Block\}}$\\[0.1in]
\end{center}

\subsubsection*{Do-while}
\begin{center}
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{boolean} \}
\end{itemize}
\noindent(\textbf{DoWhile})
$\dfrac{\Gamma \vdash RExp:\tau\ \ \ \Gamma \vdash Block}{\Gamma \vdash \texttt{do} \ \{ Block\} \ \texttt{for} \ RExp\ }$\\[0.1in]
\end{center}

\subsubsection*{For}
\begin{center}
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int,float,char,string, boolean} \}
\end{itemize}
\noindent(\textbf{For})
$\dfrac{\Gamma \vdash StatementSimple \ \ \Gamma \vdash RExp:\texttt{boolean} \ \ \Gamma \vdash StatementSimple \ \ \ \Gamma \vdash Block}{\Gamma \vdash  \texttt{for} \ \ StatementSimple \ RExp \ StatementSimple \ \{ Block\}}$\\[0.1in]
\end{center}

\subsubsection*{Assegnemento}
\begin{center}
\begin{itemize}
\item[-] Per $\tau \in$ \{ \texttt{int, float, char, string, boolean} \}
\end{itemize}
\noindent(\textbf{Asgn})
$\dfrac{\Gamma \vdash LExp:\tau\ \ \ \Gamma \vdash RExp:\tau}{\Gamma \vdash LExp \ \texttt{=} \ RExp}$\\[0.1in]
\end{center}

\subsection*{Funzioni e procedure}
\begin{center}
\noindent(\textbf{DeclFun})
$\dfrac{\Gamma \vdash \texttt{ident}\ \ \ \Gamma \vdash Params:TypeList\ \ \ \Gamma \vdash Block}{\Gamma \vdash func\ \texttt{ident}\ (TypeList)\ Type\ \{Block\}}$\\[0.1in]
\noindent(\textbf{DeclProc})
$\dfrac{\Gamma \vdash \texttt{ident}\ \ \ \Gamma \vdash Params:TypeList\ \ \ \Gamma \vdash Block}{\Gamma \vdash func\ \texttt{ident}\ (TypeList)\ void\ \{Block\}}$\\[0.1in]

\noindent(\textbf{WriteInt})
$\dfrac{\Gamma \vdash RExp:\texttt{int}}{\Gamma \vdash \texttt{writeInt}\ (\ RExp\ )}$\\[0.1in]
\noindent(\textbf{WriteFloat})
$\dfrac{\Gamma \vdash RExp:\texttt{float}}{\Gamma \vdash \texttt{writeFloat}\ (\ RExp\ )}$\\[0.1in]
\noindent(\textbf{WriteChar})
$\dfrac{\Gamma \vdash RExp:\texttt{char}}{\Gamma \vdash \texttt{writeChar}\ (\ RExp\ )}$\\[0.1in]
\noindent(\textbf{WriteString})
$\dfrac{\Gamma \vdash RExp:\texttt{string}}{\Gamma \vdash \texttt{writeString}\ (\ RExp\ )}$\\[0.1in]
\noindent(\textbf{ReadInt})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash \texttt{readInt}\ (\ )\ :\ \texttt{int}}$\\[0.1in]
\noindent(\textbf{ReadFloat})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash \texttt{readFloat}\ (\ )\ :\ \texttt{float}}$\\[0.1in]
\noindent(\textbf{ReadChar})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash\texttt{readChar}\ (\ )\ :\ \texttt{char}}$\\[0.1in]
\noindent(\textbf{ReadString})
$\dfrac{\Gamma \vdash \diamond}{\Gamma \vdash \texttt{readString}\ (\ )\ :\ \texttt{string}}$\\[0.1in]
\end{center}


\pagebreak
\section{Test Case}
Sono stati preparati dei test-case significativi che possono essere eseguiti in sequenza attraverso il comando \textit{make demo}, oppure singolarmente attraverso i comandi \textit{make demo1}, \textit{make demo2}, \textit{make demo3} e \textit{make demo4}.

\end{document}
