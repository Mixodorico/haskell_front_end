-- 
comment "//" ;
comment "/*" "*/" ;
--

entrypoints Program ;  -- il programma inizia sempre con "package"

-- rules definisce una disgiunzione di statement
rules Boolean ::= "true" | "false" ;

------------ RIGHT REXP ------------

coercions   RExp 14 ;

Or.         RExp  ::= RExp "||" RExp1 ;
And.        RExp1 ::= RExp1 "&&" RExp2 ;
Not.        RExp2 ::= "!" RExp3 ;
						
Eq.         RExp5 ::= RExp6 "==" RExp6 ;
Neq.        RExp5 ::= RExp6 "!=" RExp6 ;
Lt.         RExp5 ::= RExp6 "<"  RExp6 ;
LtE.        RExp5 ::= RExp6 "<=" RExp6 ;
Gt.         RExp5 ::= RExp6 ">"  RExp6 ;
GtE.        RExp5 ::= RExp6 ">=" RExp6 ;

Add.        RExp7 ::= RExp7 "+" RExp8 ;
Sub.        RExp7 ::= RExp7 "-" RExp8 ;

Mul.        RExp8 ::= RExp8 "*" RExp9 ;
Div.        RExp8 ::= RExp8 "/" RExp9 ;
Mod.        RExp8 ::= RExp8 "%" RExp9 ;

Neg.        RExp10 ::= "-" RExp11 ;
Ref.        RExp10 ::= "&" LExp ;

-- l'esponente viene definito tramite funzione in Go

--ExpValue.      RExp ::= Value ;

FCall.        RExp11 ::= FunCall ;

------------- TYPES ----------------

Int.       	RExp12 ::= Integer ;
Float.     	RExp12 ::= Double ;
Char.      	RExp12 ::= Char ;
String.    	RExp12 ::= String ;
Bool.      	RExp12 ::= Boolean ;

------------- LEFT EXPR -------------

coercions   LExp 2 ;

LExprex.       RExp13 ::= LExp ;

Par.           RExp14 ::= "(" RExp ")";

ExpFuncEmpty.  FunCall ::= CIdent "(" ")" ;
ExpFunc.       FunCall ::= CIdent "(" [RExp] ")" ;

Deref.         LExp ::= "*" RExp ;
PostInc.       LExp1 ::= LExp2 "++" ;
PostDecr.      LExp1 ::= LExp2 "--" ;

ExpId.         LExp ::= CIdent ;
ExpArr.        LExp ::= LExp "[" RExp "]" ;


Prog. Program ::= "package" CIdent [Decl];

-------------DICHIARAZIONI -------------

separator Decl "" ;
DeclVar. 	      Decl         ::= "var"  [CIdent] Type ;
DeclVarInit. 	  Decl         ::= "var"  [CIdent] "=" [RExp] ;   
DeclVarInitType.  Decl         ::= "var"  [CIdent] Type "=" [RExp] ;   -- aggiunta
DeclVarShort.     ShortVarDecl ::= [CIdent] ":=" [RExp] ;     -- quando non c'e' un tipo lo inferisce automaticamente

DeclFun.          Decl         ::= "func" CIdent "(" [Param] ")" Type Block ;
DeclProc.         Decl         ::= "func" CIdent "(" [Param] ")" Block ;


-- definizione parametri
ParamL.   	    Param        ::=  [CIdent] Type ;     -- di default e' passaggio per valore
ParamLPassType. Param        ::=  Pass [CIdent] Type ;

PassValue.	    Pass         ::=  "val" ;
PassRef.	    Pass         ::=  "ref" ;
PassValueRes.   Pass         ::=  "valres" ;   -- lo teniamo??

-- definizione dei tipi
TypeInt.     Type            ::= "int";
TypeBool.    Type            ::= "bool";
TypeFloat.   Type            ::= "float";
TypeChar.    Type            ::= "char";
TypeString.  Type            ::= "string";
TypeArray.   Type            ::=  "[" Integer "]" Type; 
TypePointer. Type            ::= "*" Type; 

--  
StateShortVarDecl. 	StatementSmpl ::= ShortVarDecl;
StateExp.	      	StatementSmpl ::= RExp;
StateAsgn.	   	    StatementSmpl ::= LExp "=" RExp;

BodyBlock.              Block ::= "{" [Statement] "}";

StateBlock.       	Statement ::= Block ;
StateSmpl.	  	    Statement ::= StatementSmpl ;
StateReturn.      	Statement ::= "return" RExp ;

StateIf.	  	    Statement ::= "if" RExp Block ;                                  -- singola condizione
StateIfElse.	  	Statement ::= "if" RExp Block "else" Block ;                     -- "" ""
StateIfStm.	  	    Statement ::= "if" StatementSmpl ";" RExp Block ;                -- + condizioni
StateIfElseStm.	  	Statement ::= "if" StatementSmpl ";" RExp Block "else" Block ;   -- "" ""

StateFor.	  	    Statement ::= "for" [StatementSmpl] ";" RExp ";" [StatementSmpl] Block ;
StateWhile.       	Statement ::= "for" RExp Block;                                  -- possiamo definirlo con il for

StateDecl.        	Statement ::= Decl;
StateBreak.        	Statement ::= "break"; 
StateContinue.     	Statement ::= "continue";
StateTryCatch.	  	Statement ::= "try" Block "catch" Block;
StateWrite. 		Statement ::= "write" "(" RExp ")";
StateRead.  		Statement ::= "read" "(" RExp ")"; 





(:[]).	[CIdent] ::= CIdent;
(:).	[CIdent] ::= CIdent "," [CIdent];

(:[]).	[RExp] ::= RExp;
(:).	[RExp] ::= RExp "," [RExp];

[].	    [StatementSmpl] ::= ;
(:[]).	[StatementSmpl] ::= StatementSmpl;


--


token CIdent (letter | '_')(letter | digit | '_')* ;


separator Param "," ;
separator Statement "" ;

