-- 
comment "//" ;
comment "/*" "*/" ;
--

entrypoints Program ;  -- il programma inizia sempre con "package"

-- rules definisce una disgiunzione di statement
rules Boolean ::= "true" | "false" ;

token CIdent (letter | '_')(letter | digit | '_')* ;

------------ RIGHT REXP ------------

coercions   RExp 14 ;

Or.         RExp  ::= RExp "||" RExp1 ;
And.        RExp1 ::= RExp1 "&&" RExp2 ;
Not.        RExp2 ::= "!" RExp3 ;
						
Eq.         RExp5 ::= RExp6 "==" RExp6 ;
Neq.        RExp5 ::= RExp6 "!=" RExp6 ;
Lt.         RExp5 ::= RExp6 "<"  RExp6 ;
LtE.        RExp5 ::= RExp6 "<=" RExp6 ;
Gt.         RExp5 ::= RExp6 ">"  RExp6 ;
GtE.        RExp5 ::= RExp6 ">=" RExp6 ;

Add.        RExp7 ::= RExp7 "+" RExp8 ;
Sub.        RExp7 ::= RExp7 "-" RExp8 ;

Mul.        RExp8 ::= RExp8 "*" RExp9 ;
Div.        RExp8 ::= RExp8 "/" RExp9 ;
Mod.        RExp8 ::= RExp8 "%" RExp9 ;

Neg.        RExp10 ::= "-" RExp11 ;
Ref.        RExp10 ::= "&" LExp ;
Deref.      RExp10 ::= "*" RExp ;

-- l'esponente viene definito tramite funzione in Go

--ExpValue.      RExp ::= Value ;

FCall.        RExp11 ::= FunCall ;
FRead.        RExp11 ::= ReadType ;

------------- TYPES ----------------

Int.       	RExp12 ::= Integer ;
Float.     	RExp12 ::= Double ;
Char.      	RExp12 ::= Char ;
String.    	RExp12 ::= String ;
Bool.      	RExp12 ::= Boolean ;

------------- LEFT EXPR -------------

coercions      LExp 1 ;

LExprex.       RExp13 ::= LExp ;
--Par.           RExp14 ::= "(" RExp ")";

--ExpProcEmpty.  ProcCall ::= CIdent "(" ")" ;
--ExpProc.       ProcCall ::= CIdent "(" [RExp] ")" ;

--PCall.         LExp ::= ProcCall 
--Deref.         LExp ::= "*" RExp ;
PostInc.       LExp ::= LExp1 "++" ;
PostDecr.      LExp ::= LExp1 "--" ;

BLExprex.      LExp1 ::= BLexp ;
LExpId.        LExp1 ::= CIdent ;

ExpArr.        BLexp ::= BLexp "[" RExp "]" ;
ExpArrId.      BLexp ::= CIdent "[" RExp "]" ;


Prog. Program ::= "package" CIdent [CompStatement];

-------------DICHIARAZIONI -------------

--separator Decl "" ;

rules BasicType ::= "bool" | "char" | "float" | "int" | "string" | "[" Integer "]" BasicType | "*" BasicType ;

DeclVar. 	      Decl         ::= "var"  [CIdent] BasicType ;
DeclVarInit. 	  Decl         ::= "var"  [CIdent] "=" [RExp] ;   
DeclVarInitType.  Decl         ::= "var"  [CIdent] BasicType "=" [RExp] ;   -- aggiunta

DeclVarShort.     Decl         ::= [CIdent] ":=" [RExp] ;     -- quando non c'e' un tipo lo inferisce automaticamente        

DeclF.            DeclFun      ::= "func" CIdent "(" [Param] ")" BasicType Block ;
DeclP.            DeclProc     ::= "func" CIdent "(" [Param] ")" "void" Block ;

------------- DEFINIZIONE PARAMETRI ----------------

ParamL.   	    Param        ::=  [CIdent] BasicType ;     -- di default e' passaggio per valore

{-
ParamLPassType. Param        ::=  Pass [CIdent] BasicType ;

PassValue.	    Pass         ::=  "val" ;
PassRef.	    Pass         ::=  "ref" ;
PassValueRes.   Pass         ::=  "valres" ;   -- lo teniamo??
-}

--------------- DEFINIZIONE TIPI --------------------
--StateShortVarDecl. 	StatementSmpl ::= Decl;


-- post inc e post dec valutati a livello di LExpr
--StateAsgnInc.  	    StatementSmpl ::= LExp "++";
--StateAsgnDec.  	    StatementSmpl ::= LExp "--";

BodyBlock.          Block ::= "{" [CompStatement] "}";

ExpFuncEmpty.       FunCall ::= CIdent "(" ")" ;
ExpFunc.            FunCall ::= CIdent "(" [RExp] ")" ;

StateBlock.       	Statement ::= Block ;
StateDecl.        	Statement ::= Decl;
StateDeclFun.	    Statement ::= DeclFun ;
StateDeclProc.	    Statement ::= DeclProc ;
StateFunCall.       Statement ::= FunCall ;
--StateLexp.          Statement ::= LExp ;

StateExp.	      Statement ::= LExp;
StateAsgn.	      Statement ::= LExp Assignment_op RExp;

Assign.     Assignment_op ::= "=" ;
AssgnMul.   Assignment_op ::= "*=" ;
AssgnAdd.   Assignment_op ::= "+=" ;
AssgnDiv.   Assignment_op ::= "/=" ;
AssgnSub.   Assignment_op ::= "-=" ;


StateReturn.      	Statement ::= "return" RExp ;

CompStmt.           CompStatement ::= Statement ;

StateIf.	  	    CompStatement ::= "if" RExp Block ;                         -- singola condizione
StateIfElse.	  	CompStatement ::= "if" RExp Block "else" Block ;            -- "" ""
StateIfStm.	  	    CompStatement ::= "if" Statement ";" RExp Block ;                -- + condizioni
StateIfElseStm.	  	CompStatement ::= "if" Statement ";" RExp Block "else" Block ;   -- "" ""

StateWhile.       	CompStatement ::= "for" RExp Block ;

StateBreak.        	Statement ::= "break"; 
StateContinue.     	Statement ::= "continue";
--StateTryCatch.	  	Statement ::= "try" Block "catch" Block;

rules WriteType    ::= "writeInt" | "writeFloat" | "writeChar" | "writeString" ;
rules ReadType    ::= "readInt" | "readFloat" | "readChar" | "readString" ;

StateWrite. 		Statement ::= WriteType "(" RExp ")";
StateRead.  		Statement ::= ReadType "(" ")" ; --"(" RExp ")"; 

--(:[]).	[CIdent] ::= CIdent;
--(:).	[CIdent] ::= CIdent "," [CIdent];

--(:[]).	[RExp] ::= RExp;
--(:).	[RExp] ::= RExp "," [RExp];

--[].	    [Decl] ::= ;
--(:[]).	[Decl] ::= Decl;


separator nonempty CIdent "," ;
separator nonempty RExp "," ;
separator Param "," ;
--separator Statement "" ;
separator CompStatement "" ;
