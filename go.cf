-- 
comment "//" ;
comment "/*" "*/" ;
--

entrypoints Program ;  -- il programma inizia sempre con "package"

-- rules definisce una disgiunzione di statement
rules Boolean ::= "true" | "false" ;

token CIdent (letter | '_')(letter | digit | '_')* ;

------------ RIGHT REXP ------------

coercions   RExp 13 ;

Or.         RExp  ::= RExp "||" RExp1 ;
And.        RExp1 ::= RExp1 "&&" RExp2 ;
Not.        RExp2 ::= "!" RExp3 ;
						
Eq.         RExp5 ::= RExp6 "==" RExp6 ;
Neq.        RExp5 ::= RExp6 "!=" RExp6 ;
Lt.         RExp5 ::= RExp6 "<"  RExp6 ;
LtE.        RExp5 ::= RExp6 "<=" RExp6 ;
Gt.         RExp5 ::= RExp6 ">"  RExp6 ;
GtE.        RExp5 ::= RExp6 ">=" RExp6 ;

Add.        RExp7 ::= RExp7 "+" RExp8 ;
Sub.        RExp7 ::= RExp7 "-" RExp8 ;

Mul.        RExp8 ::= RExp8 "*" RExp9 ;
Div.        RExp8 ::= RExp8 "/" RExp9 ;
Mod.        RExp8 ::= RExp8 "%" RExp9 ;

Neg.        RExp10 ::= "-" RExp11 ;
Ref.        RExp10 ::= "&" LExp ;

-- l'esponente viene definito tramite funzione in Go

--ExpValue.      RExp ::= Value ;

FCall.        RExp11 ::= FunCall ;

------------- TYPES ----------------

Int.       	RExp12 ::= Integer ;
Float.     	RExp12 ::= Double ;
Char.      	RExp12 ::= Char ;
String.    	RExp12 ::= String ;
Bool.      	RExp12 ::= Boolean ;

------------- LEFT EXPR -------------

coercions      LExp 2 ;

LExprex.       RExp13 ::= LExp ;

Par.           RExp14 ::= "(" RExp ")";

ExpFuncEmpty.  FunCall ::= CIdent "(" ")" ;
ExpFunc.       FunCall ::= CIdent "(" [RExp] ")" ;

Deref.         LExp ::= "*" RExp ;
PostInc.       LExp1 ::= LExp2 "++" ;
PostDecr.      LExp1 ::= LExp2 "--" ;

BLExprex.      LExp2 ::= BLexp ;

ExpArr.        BLexp ::= BLexp "[" RExp "]" ;
ExpId.         BLexp ::= CIdent ;



Prog. Program ::= "package" CIdent [Decl];

-------------DICHIARAZIONI -------------

separator Decl "" ;

rules BasicType ::= "void" | "bool" | "char" | "float" | "int" | "string" | "[" Integer "]" BasicType | "*" BasicType ;

DeclVar. 	      Decl         ::= "var"  [CIdent] BasicType ;
DeclVarInit. 	  Decl         ::= "var"  [CIdent] "=" [RExp] ;   
DeclVarInitType.  Decl         ::= "var"  [CIdent] BasicType "=" [RExp] ;   -- aggiunta

DeclVarShort.     ShortVarDecl ::= [CIdent] ":=" [RExp] ;     -- quando non c'e' un tipo lo inferisce automaticamente        

DeclFun.          Decl         ::= "func" CIdent "(" [Param] ")" BasicType Block ;
DeclProc.         Decl         ::= "func" CIdent "(" [Param] ")" Block ;

Assign.     Assignment_op ::= "=" ;
AssgnMul.   Assignment_op ::= "*=" ;
AssgnAdd.   Assignment_op ::= "+=" ;
AssgnDiv.   Assignment_op ::= "/=" ;
AssgnSub.   Assignment_op ::= "-=" ;

------------- DEFINIZIONE PARAMETRI ----------------

ParamL.   	    Param        ::=  [CIdent] BasicType ;     -- di default e' passaggio per valore

{-
ParamLPassType. Param        ::=  Pass [CIdent] BasicType ;

PassValue.	    Pass         ::=  "val" ;
PassRef.	    Pass         ::=  "ref" ;
PassValueRes.   Pass         ::=  "valres" ;   -- lo teniamo??
-}

--------------- DEFINIZIONE TIPI --------------------
StateShortVarDecl. 	StatementSmpl ::= ShortVarDecl;
StateExp.	      	StatementSmpl ::= RExp;
StateAsgn.	   	    StatementSmpl ::= LExp Assignment_op RExp;

-- post inc e post dec valutati a livello di LExpr
--StateAsgnInc.  	    StatementSmpl ::= LExp "++";
--StateAsgnDec.  	    StatementSmpl ::= LExp "--";

BodyBlock.          Block ::= "{" [Statement] "}";

StateBlock.       	Statement ::= Block ;
StateSmpl.	  	    Statement ::= StatementSmpl ;
StateReturn.      	Statement ::= "return" RExp ;

StateIf.	  	    Statement ::= "if" RExp Block ;                                  -- singola condizione
StateIfElse.	  	Statement ::= "if" RExp Block "else" Block ;                     -- "" ""
StateIfStm.	  	    Statement ::= "if" StatementSmpl ";" RExp Block ;                -- + condizioni
StateIfElseStm.	  	Statement ::= "if" StatementSmpl ";" RExp Block "else" Block ;   -- "" ""

StateFor.	  	    Statement ::= "for" [StatementSmpl] ";" RExp ";" [StatementSmpl] Block ;
StateWhile.       	Statement ::= "for" RExp Block;                                  -- possiamo definirlo con il for

StateDecl.        	Statement ::= Decl;
StateBreak.        	Statement ::= "break"; 
StateContinue.     	Statement ::= "continue";
StateTryCatch.	  	Statement ::= "try" Block "catch" Block;
StateWrite. 		Statement ::= "write" "(" RExp ")";
StateRead.  		Statement ::= "read" "(" RExp ")"; 



--(:[]).	[CIdent] ::= CIdent;
--(:).	[CIdent] ::= CIdent "," [CIdent];

--(:[]).	[RExp] ::= RExp;
--(:).	[RExp] ::= RExp "," [RExp];

[].	    [StatementSmpl] ::= ;
(:[]).	[StatementSmpl] ::= StatementSmpl;

separator nonempty CIdent "," ;
separator nonempty RExp "," ;
separator Param "," ;
separator Statement "" ;

