-- 
comment "//" ;
comment "/*" "*/" ;
--

entrypoints Program;  -- il programma inizia sempre con "package"

Initprogram. Program ::= "package" Id [Decl];

DeclFun.   	    Decl         ::= "func" Id "(" [Param] ")" Type Block ;
DeclProc.       Decl         ::= "func" Id "(" [Param] ")" Block ;
DeclVar. 	    Decl         ::= "var"  [Id] Type ;
DeclVarInit. 	Decl         ::= "var"  [Id] "=" [RExp] ;   
DeclVarShort.   ShortVarDecl ::= [Id] ":=" [RExp] ;     -- quando non c'e' un tipo lo inferisce automaticamente

-- definizione parametri
ParamL.   	    Param ::=  [Id] Type ;     -- di default e' passaggio per valore
ParamLPassType. Param ::=  Pass [Id] Type ;
PassValue.	    Pass  ::=  "val" ;
PassRef.	    Pass  ::=  "ref" ;
PassValueRes.   Pass  ::=  "valres" ;   -- lo teniamo??

-- definizione dei tipi
TypeInt.     Type ::= "int";
TypeBool.    Type ::= "bool";
TypeFloat.   Type ::= "float";
TypeChar.    Type ::= "char";
TypeString.  Type ::= "string";
TypeArray.   Type ::=  "[" Integer "]" Type; 
TypePointer. Type ::= "*" Type; 

--  
StateShortVarDecl. 	StatementSmpl ::= ShortVarDecl;
StateExp.	      	StatementSmpl ::= RExp;
StateAsgn.	   	    StatementSmpl ::= LExp "=" RExp;

BodyBlock. Block ::= "{" [Statement] "}";

StateBlock.       	Statement ::= Block ;
StateSmpl.	  	    Statement ::= StatementSmpl ;
StateReturn.      	Statement ::= "return" RExp ;

StateIf.	  	    Statement ::= "if" RExp Block ;                                  -- singola condizione
StateIfElse.	  	Statement ::= "if" RExp Block "else" Block ;                     -- "" ""
StateIfStm.	  	    Statement ::= "if" StatementSmpl ";" RExp Block ;                -- + condizioni
StateIfElseStm.	  	Statement ::= "if" StatementSmpl ";" RExp Block "else" Block ;   -- "" ""

StateFor.	  	    Statement ::= "for" [StatementSmpl] ";" RExp ";" [StatementSmpl] Block ;
StateWhile.       	Statement ::= "for" RExp Block;                                  -- possiamo definirlo con il for

StateDecl.        	Statement ::= Decl;
StateBreak.        	Statement ::= "break"; 
StateContinue.     	Statement ::= "continue";
StateTryCatch.	  	Statement ::= "try" Block "catch" Block;
StateWrite. 		Statement ::= "write" "(" RExp ")";
StateRead.  		Statement ::= "read" "(" RExp ")"; 

-- left expressions
ExpId.         LExp ::= Id ;
ExpArr.        LExp ::= LExp "[" RExp "]" ;
ExpDeref.      LExp ::= "*" RExp ;

-- right expressions
ExpAdd.        RExp ::= RExp "+" RExp ;
ExpSub.        RExp ::= RExp "-" RExp ;
ExpMul.        RExp ::= RExp "*" RExp ;
ExpDiv.        RExp ::= RExp "/" RExp ;
ExpMod.        RExp ::= RExp "%" RExp ;						
ExpEqu.        RExp ::= RExp "==" RExp ;
ExpNeq.        RExp ::= RExp "!=" RExp ;
LExpes.        RExp ::= RExp "<" RExp ;
LExpeq.        RExp ::= RExp "<=" RExp ;
ExpGre.        RExp ::= RExp ">" RExp ;
ExpGrq.        RExp ::= RExp ">=" RExp ;
ExpAnd.        RExp ::= RExp "&&" RExp ;
ExpOr.         RExp ::= RExp "||" RExp ;
ExpNot.        RExp ::= "!" RExp ;
ExpNeg.        RExp ::= "-" RExp ;
ExpValue.      RExp ::= Value ;
LExpef.        RExp ::= LExp ;
ExpFuncEmpty.  RExp ::= Id "(" ")" ;
ExpFunc.       RExp ::= Id "(" [RExp] ")" ;
RExpef.        RExp ::= "&" LExp ;
ExpPar.        RExp ::= "(" RExp ")";

-- definizione dei tipi
Int .       	Value ::= Integer ;
Float .     	Value ::= Double ;
Char .      	Value  ::= Char ;
String .    	Value ::= String ;
Bool .      	Value  ::= Boolean ;
BoolTrue .  	Boolean ::= "true" ;
BoolFalse . 	Boolean ::= "false" ;


(:[]).	[Id] ::= Id;
(:).	[Id] ::= Id "," [Id];

(:[]).	[RExp] ::= RExp;
(:).	[RExp] ::= RExp "," [RExp];

[].	    [StatementSmpl] ::= ;
(:[]).	[StatementSmpl] ::= StatementSmpl;


--

token Id (letter | '_')(letter | digit | '_')* ;


separator Decl "" ;
separator Param "," ;
separator Statement "" ;


